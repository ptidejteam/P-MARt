<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
    "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <title>MapperXML: General XML Components</title>
  <link href="common/style.css" rel="stylesheet" type="text/css">
</head>

<body>

<table width="100%" border="0" cellpadding="10" cellspacing="0"
style="page-break-before: always">
  <tbody>
    <tr valign="top">
      <td colspan="2" bgcolor="#e6e6ff"><img src="common/mapperlogo.gif"
        name="Graphic1" alt="Mapper Logo" align="bottom" width="500"
        height="115" border="0"></td>
    </tr>
    <tr>
      <td colspan="2" width="100%" valign="top" bgcolor="#0000ff"
      style="font-size: 3pt">.</td>
    </tr>
    <tr valign="top">
      <td width="15%" bgcolor="#9999cc">
        <div class="leftnav">
        <!--#include virtual="common/leftnavmain.shtml" -->
        </div>
      </td>
      <td width="85%"><h1>5. General XML Components</h1>

        <h2>5.1 Heirarchy</h2>
<pre>
* class com.taursys.xml.Component (implements com.taursys.util.MapperComponent)

    * class com.taursys.xml.Container
          * class com.taursys.xml.DocumentElement (implements com.taursys.xml.DocumentComponent)
                * class com.taursys.xml.Template
          * class com.taursys.servlet.ServletForm
                * class com.taursys.servlet.DefaultMessageForm
    * class com.taursys.xml.Parameter
          * class com.taursys.xml.AbstractField (implements com.taursys.xml.DocumentComponent)
                * class com.taursys.xml.CheckboxField
                      * class com.taursys.html.HTMLCheckBox
                * class com.taursys.xml.SelectField
                      * class com.taursys.html.HTMLSelect
                * class com.taursys.xml.TextField
                      * class com.taursys.html.HTMLAnchorURL
                      * class com.taursys.html.HTMLInputText
                      * class com.taursys.html.HTMLTextArea
    * class com.taursys.xml.Trigger
          * class com.taursys.xml.Button (implements com.taursys.xml.DocumentComponent)
</pre>
        <h2>5.2 Parameter</h2>

        <p>A Component which receives parameter values. A Parameter is very similar
        to an input field (AbstractField). The primary difference is WHEN they
        receive their values. Parameter values are dispatched immediately before
        the openForm method, whereas input events are dispatched immediately
        after the openForm method.</p>

        <p>Parameters have one primary property which you must set. It is the
        "parameter" property. This identifies the name of the value which
        it should listen for and respond to in the request.</p>

        <p>By default, a Parameter uses an internal DefaultTextModel with
        a VariantValueHolder and a default data type of String. You can
        change the data type when you instantiate the Parameter. The Parameter
        can also be bound to an external ValueHolder (see previous chapter).</p>

        <p>The following is an example of a Parameter which receives a
        birthdate:</p>

        <pre>
  Parameter birthdate = new Parameter(DataTypes.TYPE_DATE);
  ...
  private void jbInit() throws Exception {
    birthdate.setParameter("birthdate");
    birthdate.setFormat(java.text.SimpleDateFormat.getInstance());
    birthdate.setFormatPattern("MM/dd/yyyy");
    ...
    this.add(birthdate);
  }

  protected void openForm() throws Exception {
    // search for record by birthdate
    PersonVO person = delegate.findByBirthdate(
        (Date)birthdate.getValue());
  }
        </pre>

        <p>This component can also be bound to an external <tt>ValueHolder</tt>.
        An external <tt>ValueHolder</tt> can be shared by multiple components.
        The <tt>propertyName</tt> specifies which property in the
        <tt>ValueHolder</tt> will be bound to this component. To bind this
        component, set the <tt>valueHolder</tt> and <tt>propertyName</tt>
        properties. You do not need to specify a data type when you bind to a
        <tt>ValueHolder</tt>. The following is an example of binding:</p>

        <pre>
          Parameter latitude = new Parameter();
          Parameter longitude = new Parameter();
          VOValueHolder holder = new VOValueHolder();

          private void jbInit() throws Exception {
            holder.setValueObjectClass(LocationVO.class);

            latitude.setParameter("latitude");
            latitude.setValueHolder(holder);
            latitude.setPropertyName("physicalLatitude");

            longitude.setParameter("longitude");
            longitude.setValueHolder(holder);
            longitude.setPropertyName("physicalLongitude");
            ...
            this.add(latitude);
            this.add(longitude);
          }

          void showOnMapButton_actionPerformed(TriggerEvent e) throws Exception {
            OutputStream map = delegate.getMap((LocationVO)holder.getValueObject());
            ...
          }
        </pre>

        <h2>5.3 TextField</h2>

        <p>A component which can receive input and/or render a value to an XML document.
        This component can function in three different ways, depending on the
        properties you set:</p>

        <ul>
         <li>input only - set the <tt>parameter</tt> property.</li>
         <li>output only - set the <tt>id</tt> property.</li>
         <li>input and output - set both the <tt>parameter</tt> and
         <tt>id</tt> properties.</li>
        </ul>

        <p>When used for output, the value is rendered in the XML document  as a
        text node by default. If you want the value to be rendered to
        an attribute of the node instead, you must change the <tt>renderer</tt>
        to an <tt>AttributeTextFieldRenderer</tt> and the the <tt>attribute</tt>
        property to the name of the attribute. The below example demonstrates both cases:</p>

        <pre>
        private TextField projectStatus = new TextField();
        private TextField projectStatusColor = new TextField();

        private void jbInit() throws Exception {
          projectStatus.setId("projectStatus");
          projectStatusColor.setId("projectStatus");
          projectStatusColor.setRenderer(
              new AttributeTextFieldRenderer(projectStatusColor));
          projectStatusColor.setAttribute("bgcolor");
          ...
          this.add(projectStatus);
          this.add(projectStatusColor);
        }

        protected void openForm() throws Exception {
          ...
          projectStatus.setValue("on-schedule");
          projectStatusColor.setValue("green");
          ...
        }
        </pre>

        <p>After rendering the HTML document would appear as follows:</p>

        <pre>
        ...
        &lt;table&gt;
          &lt;tr&gt;
            &lt;td id="projectStatus" bgcolor="green"&gt;on-schedule&lt;/td&gt;
            ...
        </pre>

        <p>When used for input, this component receives its value from the
        <tt>InputDispatcher</tt> AFTER the <tt>openForm</tt> method of the
        <tt>ServletForm</tt> by default.  If you want this component to receive
        its input earlier (at the same time as <tt>Parameters</tt>), set the
        <tt>earlyInputNotify</tt> property to <tt>true</tt>.</p>

        <p>By default, this component uses an internal <tt>DefaultTextModel</tt>
        with a <tt>VariantValueHolder</tt> and a default data type of
        <tt>String</tt>. You can specify a different data type when you invoke
        the constructor of this component. Below is an example:</p>

        <pre>
          TextField salary = new TextField(DataTypes.TYPE_BIGDECIMAL);
        </pre>

        <p>This component can also be bound to an external <tt>ValueHolder</tt>.
        An external <tt>ValueHolder</tt> can be shared by multiple components.
        The <tt>propertyName</tt> specifies which property in the
        <tt>ValueHolder</tt> will be bound to this component. To bind this
        component, set the <tt>valueHolder</tt> and <tt>propertyName</tt>
        properties. You do not need to specify a data type when you bind to a
        <tt>ValueHolder</tt>. The following is an example of binding:</p>

        <pre>
          TextField personId = new TextField(DataTypes.TYPE_INT);
          TextField lastName = new TextField();
          TextField city = new TextField();
          VOValueHolder holder = new VOValueHolder();

          private void jbInit() throws Exception {
            holder.setValueObjectClass(PersonVO.class);
            ...
            personId.setParameter("personId");
            personId.setId("personId");
            personId.setEarlyInputNotify(true);
            ...
            lastName.setId("lastName");
            lastName.setValueHolder(holder);
            lastName.setPropertyName("lastName");
            ...
            city.setId("city");
            city.setValueHolder(holder);
            city.setPropertyName("address.city");
            ...
            this.add(lastName);
            this.add(city);
          }

          protected void openForm() throws java.lang.Exception {
            holder.setValueObject(
                delegate.getPerson((Integer)personId.getValue());
            ...
          }
        </pre>
        <p>Notes: In the above example, the personId field is used as a parameter
        and display field. By setting its <tt>earlyInputNotify</tt> property
        to true, it will have its value available when the <tt>openForm</tt>
        method is invoked. It is not bound to the holder. The lastName field
        functions as a display only field. It is not configured as an input field.
        The same is true of the city field. Note the city field's property name:
        "address.city". The PersonVO has an "address" property of type AddressVO.
        The AddressVO in turn has a "city" property. The dot notation supports
        multiple levels of indirection.</p>

        <h2>5.4 SelectField</h2>

        <p>This component is used to display and change a selection.
        This component, (using a <tt>DefaultSelectModel</tt>), can display a
        selection from a list of objects. It can also change the selection from
        user input.</p>

        <p>This component can be used for a variety of purposes. It can provide
        a way to display a "description" rather than a "code" for a coded value.
        It can also serve to scope user input to a subset of values.</p>

        <p>The selection is made and displayed using the property indicated by
        the <tt>displayPropertyName</tt>. The <tt>displayPropertyName</tt>
        is effectively the "selection key". If the <tt>displayPropertyName</tt>
        is null or blank, then the <tt>toString</tt> method is used instead.
        For example, given a list of Address objects, and a
        <tt>displayPropertyName</tt> of "zipCode", the display value for
        "Juneau, AK 99801 USA" would be "99801". To change the selection, you would
        supply a different zipCode from the list.</p>

        <p>This component can function in three different ways, depending on the
        properties you set:</p>

        <ul>
         <li>input only - set the <tt>parameter</tt> property.</li>
         <li>output only - set the <tt>id</tt> property.</li>
         <li>input and output - set both the <tt>parameter</tt> and
         <tt>id</tt> properties.</li>
        </ul>

        <p>When used for output, the value is rendered in the XML document  as a
        text node by default. If you want the value to be rendered to
        an attribute of the node instead, you must change the <tt>renderer</tt>
        to an <tt>AttributeTextFieldRenderer</tt> and the the <tt>attribute</tt>
        property to the name of the attribute. For rendering with an
        HTML SELECT/OPTION, use the <tt>HTMLSelect</tt> component.</p>

        <p>When used for input, this component receives its value from the
        <tt>InputDispatcher</tt> AFTER the <tt>openForm</tt> method of the
        <tt>ServletForm</tt> by default.  If you want this component to receive
        its input earlier (at the same time as <tt>Parameters</tt>), set the
        <tt>earlyInputNotify</tt> property to <tt>true</tt>.</p>

        <p>By default, this component uses a <tt>DefaultSelectModel</tt>.
        You can change this by overriding the <tt>createDefaultModel</tt> method
        or explicitly setting the <tt>model</tt> property.</p>

        <b>Setting the List</b>
        <p>
        The <tt>list</tt> must be a type of <tt>CollectionValueHolder</tt>
        (example: <tt>VOCollectionValueHolder</tt> or
        <tt>VOListValueHolder</tt>).
        The holder can contain any type of object (but they must all be instances
        of the same class).
        <p>
        If the <tt>list</tt> is an <tt>ObjectArrayValueHolder</tt>, then the
        <tt>toString()</tt> method is used as the display value (regardless of
        the <tt>displayPropertyName</tt>). If used in the bound mode, the whole
        object itself is stored in the target ValueHolder's object (regardless of
        the property names listed in the <tt>setListPropertyNames</tt> method).
        It is important to make sure that the <tt>valueHolder</tt> property
        is the same type as the objects in the <tt>ObjectArrayValueHolder</tt>
        or a <tt>ModelException</tt> will occur.
        <p>
        You can also preset the <tt>list</tt> in the constructor by passing it an
        array of Objects to be used for the <tt>list</tt>. The resulting
        <tt>list</tt> will be an <tt>ObjectArrayValueHolder</tt>.
        <p>
        The following is an example of this usage:</p>

        <pre>
          SelectField color = new SelectField(new String[] {
              "Red", "Orange", "Yellow", "Green", "Blue", "Indigo", "Violet",
              });
          ...
          private void jbInit() throws Exception {
            ...
            color.setParameter("color");
            color.setId("color");
            ...
            this.add(color);
          }
        </pre>

        <p>This component can be used in a variety of ways. It can be used in an
        un-bound mode, where the current selection is maintained internally. It can
        also be used in a bound mode where the current selection is propagated to a
        value holder. When used in the bound mode, either a single property, or
        multiple properties can be set in the value holder. The following sections
        describe the required settings to make for each of the modes.</p>

        <b>Un-bound Mode (uses internal VariantValueHolder)</b>
        <p>
        When used in this mode this component uses an internal
        <tt>VariantValueHolder</tt> to hold the current selection. By default a
        <tt>VariantValueHolder</tt> is created with a data type of
        <tt>String</tt>. To set a different data type use the constructor which
        takes a data type as a parameter. (example
        <tt>new SelectField(DataTypes.TYPE_INT)</tt>).
        <p>
        To use this component in the un-bound mode, you must set the following
        properties:
        <ul>
        <li><tt>list</tt> - should be set to a type of
        <tt>CollectionHolder</tt> which holds the list of options
        (see "Setting the List").
        </li>
        <li><tt>displayPropertyName</tt> - the name of the property to display
        (property of objects in list). Example: given a list of "Location" objects
        with a property called "locationName", use
        <tt>setDisplayPropertyName("locationName")</tt>
        to display the zipCode. IMPORTANT - The displayed property choosen must
        result in a unique list of values, otherwise the intended value may not be
        selected/displayed.
        </li>
        <li><tt>listPropertyNames</tt> - set a single source property name in the
        <tt>list</tt> objects. Example: Given a list containing "Location"
        objects which has properties "zipCode", "cityName", "stateAbbr", and
        "country", to make the zipcode the internal value use
        <tt>setListPropertyNames(new String[] {"zipCode"})</tt>.
        <p>
        If the <tt>list</tt> is an <tt>ObjectArrayValueHolder</tt>, then
        the property name should always be a single "value" (which is the default).
        </li>
        <li><tt>propertyName</tt> - must be "value" (which is the default).
        </li>
        <li><tt>nullDisplay</tt> - String to display in list for null selection.
        Example: "--- Nothing Selected ---"
        </li>
        </ul>
        <b>Bound Mode</b>
        <p>
        To use this component in the bound mode, use the same properties as
        described in the Un-bound Mode, plus the following additional properties:
        <ul>
        <li><tt>valueHolder</tt> - should be set to the target
        <tt>ValueHolder</tt> which contains the current selection and will be
        updated if the selection is changed.
        </li>
        <li><tt>propertyName</tt> - set this to the first (or only)
        <tt>ValueHolder</tt> object property name which will be bound to the
        selection. Example: given a <tt>ValueHolder</tt> with an
        "Address" object which has a "zipCode" property, use
        <tt>setPropertyName("zipCode")</tt> to store the current selection in
        the "Address.zipCode" property.
        </li>
        <li><tt>propertyNames</tt> - use this when you want to set more than
        1 property in the <tt>ValueHolder</tt> object. Example: assume you want
        to set not only the "zipCode" property, but also the "city", "state" and
        "country" properties, use
        <tt>setPropertyNames(new String[] {"zipCode","city","state","country"})</tt>
        </li>
        <li><tt>listPropertyNames</tt> - set the to the source property name(s)
        in the <tt>list</tt> objects. IMPORTANT - The name(s) of the
        <tt>listPropertyNames</tt> properties MUST be
        in the same ORDER as the <tt>propertyName(s)</tt>. The names in the
        <tt>listPropertNames</tt> may be different than the names in the
        <tt>propertyNames</tt> since they are associated
        with in objects in the <tt>list</tt>, not the <tt>valueHolder</tt>.
        Example: Given a <tt>list</tt>
        containing "Location" objects which has properties "zipCode", "cityName",
        "stateAbbr", and "country", for a single property use
        <tt>setListPropertyNames(new String[] {"zipCode"})</tt>. For
        multiple properties use
        <tt>setListPropertyNames(new String[] {"zipCode", "cityName", "stateAbbr",
        "country"})</tt>
        <p>
        If the <tt>list</tt> is an <tt>ObjectArrayValueHolder</tt>, then
        the property name should always be a single "value" (which is the default).
        </li>
        </ul>

        <b>Other Important Information</b>
        <p>
        When a selection is made, the values are copied from the properties in the
        <tt>list</tt> to the properties in the <tt>valueHolder</tt> object.
        The property names in <tt>propertyNames[]</tt> and
        <tt>listPropertyNames[]</tt> must appear in a corresponding order.
        <p>
        A "null" item will always be added to the <tt>displayOptionList</tt>.
        When the "null" item is selected, a null will be assigned to the
        <tt>propertyNames[]</tt> in the <tt>valueHolder</tt> object.
        The actual "null" item to to display is defined by the
        <tt>nullDisplay</tt> (default is "--none--").
        <p>
        The <tt>format</tt> and <tt>formatPattern</tt> govern the display
        property in this component.  The <tt>getText</tt> method returns the
        formatted display property, while the <tt>setText</tt>
        method changes the current selection to one whose display matches the given
        value. If you attempt to <tt>setText</tt> for an item that is not in
        the list, a <tt>NotInListException</tt> will be thrown.

        <h2>5.5 CheckboxField</h2>

        <p>This component is used to display and change a "selected indicator".
        This component uses a <tt>DefaultCheckboxModel</tt> to manage the
        state. There are only two states for this component: selected or
        not-selected.</p>

        <p>To use this component you must first set the the following properties
        as indicated:</p>
        <ul>
        <li><tt>selectedValue</tt> - the text value which indicates a
        "selected" state. The default value is "true".</li>
        <li><tt>unselectedValue</tt> - the text value which indicates an
        "un-selected" state. The default value is "" (blank) which will result
        in a <tt>null</tt> value being stored in the <tt>valueHolder</tt></li>
        </ul>

        <p>This component can function in three different ways, depending on the
        properties you set:</p>

        <ul>
         <li>input only - set the <tt>parameter</tt> property.</li>
         <li>output only - set the <tt>id</tt> property.</li>
         <li>input and output - set both the <tt>parameter</tt> and
         <tt>id</tt> properties.</li>
        </ul>

        <p>When used for output, the value is rendered in the XML document as a
        text node by default. If you want the value to be rendered to
        an attribute of the node instead, you must change the <tt>renderer</tt>
        to an <tt>AttributeTextFieldRenderer</tt> and the the <tt>attribute</tt>
        property to the name of the attribute. For rendering with an
        HTML input type checkbox, use the <tt>HTMLCheckBox</tt> component.</p>

        <p>When used for input, this component receives its value from the
        <tt>InputDispatcher</tt> AFTER the <tt>openForm</tt> method of the
        <tt>ServletForm</tt> by default.  If you want this component to receive
        its input earlier (at the same time as <tt>Parameters</tt>), set the
        <tt>earlyInputNotify</tt> property to <tt>true</tt>.</p>

        <p>By default, this component uses a <tt>DefaultCheckboxModel</tt>.
        You can change this by overriding the <tt>createDefaultModel</tt> method
        or explicitly setting the <tt>model</tt> property.</p>

        <p>This component can be used in a variety of ways. It can be used in an
        un-bound mode, where the current selected state is maintained internally.
        It can also be used in a bound mode where the current selected state is
        propagated to a value holder. When used in the bound mode a single property
        can be set in the value holder. The following sections describe the required
        settings to make for each of the modes.</p>

        <b>Un-bound Mode</b>

        <p>To use this component in the un-bound mode, you can set the following
        properties:</p>
        <ul>
        <li><tt>selectedValue</tt> - the text value which indicates a
        "selected" state. The default value is "true".</li>
        <li><tt>unselectedValue</tt> - the text value which indicates an
        "un-selected" state. The default value is "" (blank) which will result
        in a <tt>null</tt> value being stored in the <tt>valueHolder</tt></li>
        </ul>

        <b>Bound Mode</b>

        <p>To use this component in the bound mode, use the same properties as
        described in the Un-bound Mode, plus the following additional properties:</p>
        <ul>
        <li><tt>valueHolder</tt> - should be bound to the
        <tt>ValueHolder</tt> which contains the current selected state and is to
        be updated if the state is changed.</li>

        <li><tt>propertyName</tt> - set this to the property
        name (belonging to the object in the <tt>ValueHolder</tt>) which will
        be bound to the selected state. Example: given a <tt>ValueHolder</tt>
        with an "Address" object which has a "active" property, use
        <tt>setPropertyName("active")</tt> to store the current selected state in
        the "Address.active" property.</li>
        </ul>

        <h2>5.6 Trigger</h2>

        <h2>5.7 Button</h2>

        <h2>5.8 Template</h2>
      </td>
    </tr>
    <tr>
      <td colspan="2" width="100%" valign="top" bgcolor="#9999ff"
      style="font-size: 3pt">.</td>
    </tr>
  </tbody>
</table>

<div class="footer">
<!--#include virtual="common/footer.shtml" -->
</div>
</body>
</html>
