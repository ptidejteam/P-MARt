/*
 *  Initiative - A role playing utility to track turns
 *  Copyright (C) 2002 Devon D Jones
 *
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation; either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program; if not, write to the Free Software
 *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 *
 *  The author of this program grants you the ability to use this code
 *  in conjunction with code that is covered under the Open Gaming License
 *
 *  Initiative.java
 *
 *  Created on September 18, 2002, 4:36 PM
 */
package plugin.initiative.gui;

import gmgen.GMGenSystem;
import gmgen.io.SimpleFileFilter;
import gmgen.plugin.Combatant;
import gmgen.plugin.Dice;
import gmgen.plugin.Event;
import gmgen.plugin.InfoCharacterDetails;
import gmgen.plugin.InitHolder;
import gmgen.plugin.InitHolderList;
import gmgen.plugin.PcgCombatant;
import gmgen.plugin.Spell;
import gmgen.plugin.SystemHP;
import gmgen.plugin.SystemInitiative;
import gmgen.pluginmgr.GMBComponent;
import gmgen.util.LogUtilities;
import java.awt.Component;
import java.awt.Frame;
import java.io.File;
import java.io.FileWriter;
import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.ListIterator;
import java.util.Vector;
import javax.swing.JButton;
import javax.swing.JCheckBox;
import javax.swing.JFileChooser;
import javax.swing.JOptionPane;
import javax.swing.event.HyperlinkEvent;
import javax.swing.event.HyperlinkListener;
import javax.swing.event.ListSelectionEvent;
import javax.swing.event.ListSelectionListener;
import javax.swing.table.DefaultTableModel;
import javax.swing.table.JTableHeader;
import javax.swing.table.TableColumn;
import javax.swing.table.TableColumnModel;
import org.jdom.Document;
import org.jdom.Element;
import org.jdom.input.SAXBuilder;
import pcgen.core.Globals;
import pcgen.core.PlayerCharacter;
import pcgen.core.SettingsHandler;
import pcgen.core.StatList;
import pcgen.util.Logging;
import plugin.initiative.AttackModel;
import plugin.initiative.InitOutputter;
import plugin.initiative.InitiativePlugin;
import plugin.initiative.PObjectModel;
import plugin.initiative.SkillModel;
import plugin.initiative.SpellModel;
import plugin.initiative.XMLCombatant;

/**
 *@author     Devon Jones
 *@created    March 20, 2003
 */
public class Initiative extends javax.swing.JPanel {
	/*
	 *  History:
	 *  March 20, 2003: Cleanup for Version 1.0
	 */

	/**  Creates new form Initiative */
	public Initiative() {
		initComponents();
		initDynamicComponents();
		initPrefs();
		initTable();
		initLast();
		addTableListener();
		jSplitPane1.setOneTouchExpandable(true);
	}


	/**
	 *  Constructor for the Initiative object
	 *
	 *@param  main  Frame that the init object will reside in.
	 */
	public Initiative(java.awt.Frame main) {
		mainFrame = main;
		initComponents();
		initDynamicComponents();
		initPrefs();
		initTable();
		initLast();
		addTableListener();
		jSplitPane1.setOneTouchExpandable(true);
	}


	/**
	 *  This method is called from within the constructor to initialize the form.
	 *  WARNING: Do NOT modify this code. The content of this method is always
	 *  regenerated by the Form Editor.
	 */
	private void initComponents() {//GEN-BEGIN:initComponents
		tablePopup = new javax.swing.JPopupMenu();
		tablePopupCBNumber = new javax.swing.JCheckBoxMenuItem();
		tablePopupCBName = new javax.swing.JCheckBoxMenuItem();
		tablePopupCBPlayer = new javax.swing.JCheckBoxMenuItem();
		tablePopupCBStatus = new javax.swing.JCheckBoxMenuItem();
		tablePopupCBPlus = new javax.swing.JCheckBoxMenuItem();
		tablePopupCBInitiative = new javax.swing.JCheckBoxMenuItem();
		tablePopupCBDuration = new javax.swing.JCheckBoxMenuItem();
		tablePopupCBHP = new javax.swing.JCheckBoxMenuItem();
		tablePopupCBHPMax = new javax.swing.JCheckBoxMenuItem();
		tablePopupCBType = new javax.swing.JCheckBoxMenuItem();
		jToolBar1 = new javax.swing.JToolBar();
		jPanel10 = new javax.swing.JPanel();
		bRoll = new javax.swing.JButton();
		bAddCombatant = new javax.swing.JButton();
		bNextInit = new javax.swing.JButton();
		bRefocus = new javax.swing.JButton();
		bCombatantReRoll = new javax.swing.JButton();
		bDelete = new javax.swing.JButton();
		bSetType = new javax.swing.JButton();
		jPanel2 = new javax.swing.JPanel();
		lCounter = new javax.swing.JLabel();
		jSplitPane1 = new javax.swing.JSplitPane();
		jScrollPane1 = new javax.swing.JScrollPane();
		combatantTable = new javax.swing.JTable();
		tpaneInfo = new javax.swing.JTabbedPane();
		tpCombatInfo = new javax.swing.JTextArea();
		tpCombatInfo.setName("Events");
		jToolBar2 = new javax.swing.JToolBar();

		tablePopupCBNumber.setText("#");
		tablePopupCBNumber.addActionListener(new java.awt.event.ActionListener() {
			public void actionPerformed(java.awt.event.ActionEvent evt) {
				TablePopupActionPerformed(evt);
			}
		});

		tablePopup.add(tablePopupCBNumber);
		tablePopupCBName.setText("Name");
		tablePopupCBName.addActionListener(new java.awt.event.ActionListener() {
			public void actionPerformed(java.awt.event.ActionEvent evt) {
				TablePopupActionPerformed(evt);
			}
		});

		tablePopup.add(tablePopupCBName);
		tablePopupCBPlayer.setText("Player");
		tablePopupCBPlayer.addActionListener(new java.awt.event.ActionListener() {
			public void actionPerformed(java.awt.event.ActionEvent evt) {
				TablePopupActionPerformed(evt);
			}
		});

		tablePopup.add(tablePopupCBPlayer);
		tablePopupCBStatus.setText("Status");
		tablePopupCBStatus.addActionListener(new java.awt.event.ActionListener() {
			public void actionPerformed(java.awt.event.ActionEvent evt) {
				TablePopupActionPerformed(evt);
			}
		});

		tablePopup.add(tablePopupCBStatus);
		tablePopupCBPlus.setText("Plus");
		tablePopupCBPlus.addActionListener(new java.awt.event.ActionListener() {
			public void actionPerformed(java.awt.event.ActionEvent evt) {
				TablePopupActionPerformed(evt);
			}
		});

		tablePopup.add(tablePopupCBPlus);
		tablePopupCBInitiative.setText("Initiative");
		tablePopupCBInitiative.addActionListener(new java.awt.event.ActionListener() {
			public void actionPerformed(java.awt.event.ActionEvent evt) {
				TablePopupActionPerformed(evt);
			}
		});

		tablePopup.add(tablePopupCBInitiative);
		tablePopupCBDuration.setText("Duration");
		tablePopupCBDuration.addActionListener(new java.awt.event.ActionListener() {
			public void actionPerformed(java.awt.event.ActionEvent evt) {
				TablePopupActionPerformed(evt);
			}
		});

		tablePopup.add(tablePopupCBDuration);
		tablePopupCBHP.setText("HP");
		tablePopupCBHP.setEnabled(false);
		tablePopupCBHP.addActionListener(new java.awt.event.ActionListener() {
			public void actionPerformed(java.awt.event.ActionEvent evt) {
				TablePopupActionPerformed(evt);
			}
		});

		tablePopup.add(tablePopupCBHP);
		tablePopupCBHPMax.setText("HP Max");
		tablePopupCBHPMax.setEnabled(false);
		tablePopupCBHPMax.addActionListener(new java.awt.event.ActionListener() {
			public void actionPerformed(java.awt.event.ActionEvent evt) {
				TablePopupActionPerformed(evt);
			}
		});

		tablePopup.add(tablePopupCBHPMax);
		tablePopupCBType.setText("Type");
		tablePopupCBType.addActionListener(new java.awt.event.ActionListener() {
			public void actionPerformed(java.awt.event.ActionEvent evt) {
				TablePopupActionPerformed(evt);
			}
		});

		tablePopup.add(tablePopupCBType);

		setLayout(new java.awt.BorderLayout());

		setPreferredSize(new java.awt.Dimension(700, 600));
		jPanel10.setLayout(new javax.swing.BoxLayout(jPanel10, javax.swing.BoxLayout.X_AXIS));

		bRoll.setText("Start Combat");
		bRoll.addActionListener(new java.awt.event.ActionListener() {
			public void actionPerformed(java.awt.event.ActionEvent evt) {
				bRollActionPerformed(evt);
			}
		});

		jPanel10.add(bRoll);

		bAddCombatant.setText("Add Combatant");
		bAddCombatant.addActionListener(new java.awt.event.ActionListener() {
			public void actionPerformed(java.awt.event.ActionEvent evt) {
				bAddCombatantActionPerformed(evt);
			}
		});

		jPanel10.add(bAddCombatant);

		bNextInit.setText("Next Initiative");
		bNextInit.addActionListener(new java.awt.event.ActionListener() {
			public void actionPerformed(java.awt.event.ActionEvent evt) {
				bNextInitActionPerformed(evt);
			}
		});

		jPanel10.add(bNextInit);

		bRefocus.setText("Refocus");
		bRefocus.addActionListener(new java.awt.event.ActionListener() {
			public void actionPerformed(java.awt.event.ActionEvent evt) {
				bRefocusActionPerformed(evt);
			}
		});

		jPanel10.add(bRefocus);

		bCombatantReRoll.setText("Roll");
		bCombatantReRoll.addActionListener(new java.awt.event.ActionListener() {
			public void actionPerformed(java.awt.event.ActionEvent evt) {
				bCombatantReRollActionPerformed(evt);
			}
		});

		jPanel10.add(bCombatantReRoll);

		bDelete.setText("Delete");
		bDelete.addActionListener(new java.awt.event.ActionListener() {
			public void actionPerformed(java.awt.event.ActionEvent evt) {
				bDeleteActionPerformed(evt);
			}
		});

		jPanel10.add(bDelete);

		bSetType.setText("Set Type");
		bSetType.addActionListener(new java.awt.event.ActionListener() {
			public void actionPerformed(java.awt.event.ActionEvent evt) {
				bSetTypeActionPerformed(evt);
			}
		});

		jPanel10.add(bSetType);

		jToolBar1.add(jPanel10);

		jToolBar1.add(jPanel2);

		lCounter.setFont(new java.awt.Font("Dialog", 0, 18));
		jToolBar1.add(lCounter);

		add(jToolBar1, java.awt.BorderLayout.NORTH);

		jSplitPane1.setDividerLocation(400);
		jSplitPane1.setOneTouchExpandable(true);
		jSplitPane1.setPreferredSize(new java.awt.Dimension(800, 405));
		combatantTable.addMouseListener(new java.awt.event.MouseAdapter() {
			public void mousePressed(java.awt.event.MouseEvent evt) {
				combatantTableMousePressed(evt);
			}
			public void mouseReleased(java.awt.event.MouseEvent evt) {
				combatantTableMouseReleased(evt);
			}
		});

		combatantTable.addPropertyChangeListener(new java.beans.PropertyChangeListener() {
			public void propertyChange(java.beans.PropertyChangeEvent evt) {
				combatantTablePropertyChange(evt);
			}
		});

		jScrollPane1.setViewportView(combatantTable);

		jSplitPane1.setLeftComponent(jScrollPane1);

		tpaneInfo.addTab("Events", tpCombatInfo);

		jSplitPane1.setRightComponent(tpaneInfo);

		add(jSplitPane1, java.awt.BorderLayout.CENTER);

		add(jToolBar2, java.awt.BorderLayout.SOUTH);

	}//GEN-END:initComponents

	private void bSetTypeActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_bSetTypeActionPerformed
		setCombatantType();
	}//GEN-LAST:event_bSetTypeActionPerformed


	private void combatantTablePropertyChange(java.beans.PropertyChangeEvent evt) {
		//GEN-FIRST:event_combatantTablePropertyChange
		editTableRow();
		refreshTable();
	}
	//GEN-LAST:event_combatantTablePropertyChange


	private void combatantTableMouseReleased(java.awt.event.MouseEvent evt) {
		//GEN-FIRST:event_combatantTableMouseReleased
		if (evt.isPopupTrigger()) {
			initTablePopup();
			tablePopup.show(evt.getComponent(), evt.getX(), evt.getY());
		}
	}
	//GEN-LAST:event_combatantTableMouseReleased


	private void bDeleteActionPerformed(java.awt.event.ActionEvent evt) {
		//GEN-FIRST:event_bDeleteActionPerformed
		deleteCombatant();
		focusNextInit();
	}
	//GEN-LAST:event_bDeleteActionPerformed


	private void bCombatantReRollActionPerformed(java.awt.event.ActionEvent evt) {
		//GEN-FIRST:event_bCombatantReRollActionPerformed
		rerollCombatant();
		focusNextInit();
	}
	//GEN-LAST:event_bCombatantReRollActionPerformed


	private void bRefocusActionPerformed(java.awt.event.ActionEvent evt) {
		//GEN-FIRST:event_bRefocusActionPerformed
		refocusCombatant();
		focusNextInit();
	}
	//GEN-LAST:event_bRefocusActionPerformed


	private void bNextInitActionPerformed(java.awt.event.ActionEvent evt) {
		//GEN-FIRST:event_bNextInitActionPerformed
		nextInit();
	}
	//GEN-LAST:event_bNextInitActionPerformed


	private void bAddCombatantActionPerformed(java.awt.event.ActionEvent evt) {
		//GEN-FIRST:event_bAddCombatantActionPerformed
		addCombatant();
	}
	//GEN-LAST:event_bAddCombatantActionPerformed

	private void bRollActionPerformed(java.awt.event.ActionEvent evt) {
		//GEN-FIRST:event_bRollActionPerformed
		roll();
		focusNextInit();
	}
	//GEN-LAST:event_bRollActionPerformed


	private void combatantTableMousePressed(java.awt.event.MouseEvent evt) {
		//GEN-FIRST:event_combatantTableMousePressed
		if (evt.isPopupTrigger()) {
			initTablePopup();
			tablePopup.show(evt.getComponent(), evt.getX(), evt.getY());
		}
	}
	//GEN-LAST:event_combatantTableMousePressed


	private void TablePopupActionPerformed(java.awt.event.ActionEvent evt) {
		//GEN-FIRST:event_TablePopupActionPerformed
		checkAndFixColumns(tablePopupCBName.getState(), "Name");
		checkAndFixColumns(tablePopupCBPlayer.getState(), "Player");
		checkAndFixColumns(tablePopupCBStatus.getState(), "Status");
		checkAndFixColumns(tablePopupCBPlus.getState(), "+");
		checkAndFixColumns(tablePopupCBInitiative.getState(), "Init");
		checkAndFixColumns(tablePopupCBDuration.getState(), "Dur");
		checkAndFixColumns(tablePopupCBHP.getState(), "HP");
		checkAndFixColumns(tablePopupCBHPMax.getState(), "HP Max");
		checkAndFixColumns(tablePopupCBNumber.getState(), "#");
		checkAndFixColumns(tablePopupCBType.getState(), "Type");
		refreshTable();
	}
	//GEN-LAST:event_TablePopupActionPerformed


	private void bSaveActionPerformed(java.awt.event.ActionEvent evt) {
		rollSave();
	}

	private void bCastActionPerformed(java.awt.event.ActionEvent evt) {
		castSpell();
		focusNextInit();
	}

	private void bEventActionPerformed(java.awt.event.ActionEvent evt) {
		startEvent();
		focusNextInit();
	}


	private void bKillActionPerformed(java.awt.event.ActionEvent evt) {
		killCombatant();
		focusNextInit();
	}


	private void showDeadActionPerformed(java.awt.event.ActionEvent evt) {
		checkDeadTabs();
		refreshTable();
		focusNextInit();
	}

	private void showEventsActionPerformed(java.awt.event.ActionEvent evt) {
		refreshTable();
		focusNextInit();
		SettingsHandler.setGMGenOption(InitiativePlugin.LOG_NAME + ".ShowEvents", showEvents.isSelected());
	}

	private void bDamageActionPerformed(java.awt.event.ActionEvent evt) {
		damageCombatant();
		focusNextInit();
	}


	private void bHealActionPerformed(java.awt.event.ActionEvent evt) {
		healCombatant();
		focusNextInit();
	}


	private void bStabilizeActionPerformed(java.awt.event.ActionEvent evt) {
		stabilizeCombatant();
		refreshTable();
		focusNextInit();
	}


	private void bRaiseActionPerformed(java.awt.event.ActionEvent evt) {
		raiseCombatant();
		refreshTable();
		focusNextInit();
	}


	private void colModAdded(javax.swing.event.TableColumnModelEvent evt) {
	}


	private void colModMarginChanged(javax.swing.event.ChangeEvent evt) {
		trackTable();
	}


	private void colModMoved(javax.swing.event.TableColumnModelEvent evt) {
		trackTable();
	}


	private void colModRemoved(javax.swing.event.TableColumnModelEvent evt) {
	}


	private void colModSelectionChanged(javax.swing.event.ListSelectionEvent evt) {
	}


	//** Initialization Functions **
	private void initDynamicComponents() {
		bSave.setText("Roll Save");
		bSave.addActionListener(
			new java.awt.event.ActionListener() {
				public void actionPerformed(java.awt.event.ActionEvent evt) {
					bSaveActionPerformed(evt);
				}
			}
		);

		bCast.setText("Cast Spell");
		bCast.addActionListener(
			new java.awt.event.ActionListener() {
				public void actionPerformed(java.awt.event.ActionEvent evt) {
					bCastActionPerformed(evt);
				}
			}
		);

		bEvent.setText("Start Event");
		bEvent.addActionListener(
			new java.awt.event.ActionListener() {
				public void actionPerformed(java.awt.event.ActionEvent evt) {
					bEventActionPerformed(evt);
				}
			}
		);

		bKill.setText("Kill");
		bKill.addActionListener(
			new java.awt.event.ActionListener() {
				public void actionPerformed(java.awt.event.ActionEvent evt) {
					bKillActionPerformed(evt);
				}
			}
		);

		bDamage.setText("Damage");
		bDamage.addActionListener(
			new java.awt.event.ActionListener() {
				public void actionPerformed(java.awt.event.ActionEvent evt) {
					bDamageActionPerformed(evt);
				}
			}
		);

		bHeal.setText("Heal");
		bHeal.addActionListener(
			new java.awt.event.ActionListener() {
				public void actionPerformed(java.awt.event.ActionEvent evt) {
					bHealActionPerformed(evt);
				}
			}
		);

		bStabilize.setText("Stabilize");
		bStabilize.addActionListener(
			new java.awt.event.ActionListener() {
				public void actionPerformed(java.awt.event.ActionEvent evt) {
					bStabilizeActionPerformed(evt);
				}
			}
		);

		bRaise.setText("Raise");
		bRaise.addActionListener(
			new java.awt.event.ActionListener() {
				public void actionPerformed(java.awt.event.ActionEvent evt) {
					bRaiseActionPerformed(evt);
				}
			}
		);

		showDead.setSelected(true);
		showDead.setText("Show Dead");
		showDead.addActionListener(
			new java.awt.event.ActionListener() {
				public void actionPerformed(java.awt.event.ActionEvent evt) {
					showDeadActionPerformed(evt);
				}
			}
		);

		showEvents.setSelected(true);
		showEvents.setText("Show Events");
		showEvents.addActionListener(
			new java.awt.event.ActionListener() {
				public void actionPerformed(java.awt.event.ActionEvent evt) {
					showEventsActionPerformed(evt);
				}
			}
		);

	}


	private void initTablePopup() {
		TableColumnModel colModel = combatantTable.getColumnModel();
		int numCols = colModel.getColumnCount();
		tablePopupCBName.setSelected(false);
		tablePopupCBPlayer.setSelected(false);
		tablePopupCBStatus.setSelected(false);
		tablePopupCBPlus.setSelected(false);
		tablePopupCBInitiative.setSelected(false);
		tablePopupCBDuration.setSelected(false);
		tablePopupCBHP.setSelected(false);
		tablePopupCBHPMax.setSelected(false);
		tablePopupCBNumber.setSelected(false);
		tablePopupCBType.setSelected(false);
		for (int i = 0; i < numCols; i++) {
			TableColumn col = colModel.getColumn(i);
			String name = col.getIdentifier().toString();
			if (name.equals("Name")) {
				tablePopupCBName.setSelected(true);
			}
			else if (name.equals("Player")) {
				tablePopupCBPlayer.setSelected(true);
			}
			else if (name.equals("Status")) {
				tablePopupCBStatus.setSelected(true);
			}
			else if (name.equals("+")) {
				tablePopupCBPlus.setSelected(true);
			}
			else if (name.equals("Init")) {
				tablePopupCBInitiative.setSelected(true);
			}
			else if (name.equals("Dur")) {
				tablePopupCBDuration.setSelected(true);
			}
			else if (name.equals("HP")) {
				tablePopupCBHP.setSelected(true);
			}
			else if (name.equals("HP Max")) {
				tablePopupCBHPMax.setSelected(true);
			}
			else if (name.equals("#")) {
				tablePopupCBNumber.setSelected(true);
			}
			else if (name.equals("Type")) {
				tablePopupCBType.setSelected(true);
			}
		}
		if (SettingsHandler.getGMGenOption(InitiativePlugin.LOG_NAME + ".doSpells", true) || SettingsHandler.getGMGenOption(InitiativePlugin.LOG_NAME + ".doDeath", true) || SettingsHandler.getGMGenOption(InitiativePlugin.LOG_NAME + ".doHP", true)) {
			tablePopupCBDuration.setEnabled(true);
		}
		else {
			tablePopupCBDuration.setEnabled(false);
		}
		if (SettingsHandler.getGMGenOption(InitiativePlugin.LOG_NAME + ".doHP", true)) {
			tablePopupCBHP.setEnabled(true);
			tablePopupCBHPMax.setEnabled(true);
		}
		else {
			tablePopupCBHP.setEnabled(false);
			tablePopupCBHPMax.setEnabled(false);
		}
		if (SettingsHandler.getGMGenOption(InitiativePlugin.LOG_NAME + ".doNumber", true)) {
			tablePopupCBNumber.setEnabled(true);
		}
	}


	private void initTable() {
		initTableColumns();
		JTableHeader header = combatantTable.getTableHeader();
		header.addMouseListener(
			new java.awt.event.MouseAdapter() {
				public void mousePressed(java.awt.event.MouseEvent evt) {
					combatantTableMousePressed(evt);
				}


				public void mouseReleased(java.awt.event.MouseEvent evt) {
					combatantTableMouseReleased(evt);
				}
			});
		columnList = getColumnOrder();
		combatantTable.getSelectionModel().addListSelectionListener(new ListSelectionListener()
		{
			public void valueChanged(ListSelectionEvent e)
			{
				listSelectionChaned(e);
	}
		});
	}


	/**
	 * <p>
	 * Fired when the selection in the <code>combatantTable</code> changes;
	 * if any rows are selected, it synchronizes the tab view with the first
	 * selected row.
	 * </p>
	 *
	 * @param e
	 *            <code>ListSelectionEvent</code> which fired this method
	 */
	protected void listSelectionChaned(ListSelectionEvent e)
	{
		final int row = combatantTable.getSelectedRow();
		if (row >= 0)
		{
			final String name =
				(String) combatantTable.getValueAt(
					row,
					combatantTable.getColumnModel().getColumnIndex("Name"));
			if (name != null
				&& name.length() > 0
				&& tpaneInfo.getSelectedIndex() != tpaneInfo.indexOfTab("Events")
				&& tpaneInfo.indexOfTab(name) >= 0)
			{
				tpaneInfo.setSelectedIndex(tpaneInfo.indexOfTab(name));
			}
		}
	}


	private void initTableColumns() {
		DefaultTableModel tabModel = (DefaultTableModel) combatantTable.getModel();
		tabModel.setColumnCount(0);
		int colNo = SettingsHandler.getGMGenOption(InitiativePlugin.LOG_NAME + ".NumberOfColumns", 0);
		int[] widths = new int[colNo];
		for (int i = 0; i < colNo; i++) {
			String name = SettingsHandler.getGMGenOption(InitiativePlugin.LOG_NAME + ".ColumnName." + i, "");
			int width = SettingsHandler.getGMGenOption(InitiativePlugin.LOG_NAME + ".ColumnWidth." + i, 100);
			addColumn(name, width);
			widths[i] = width;
		}
		setColumnWidths(widths);
	}


	/**
	 *  Initialization of the bulk of preferences.  sets the defaults
	 *  if this is the first time you have used this version
	 */
	public void initPrefs() {
		boolean prefsSet = SettingsHandler.getGMGenOption(InitiativePlugin.LOG_NAME + ".arePrefsSet", false);
		if (!prefsSet) {
			SettingsHandler.setGMGenOption(InitiativePlugin.LOG_NAME + ".arePrefsSet", true);
		}
		Double version = SettingsHandler.getGMGenOption(InitiativePlugin.LOG_NAME + ".Version", 0.0);
		Double subversion = SettingsHandler.getGMGenOption(InitiativePlugin.LOG_NAME + ".SubVersion", 0.0);

		if (version.doubleValue() < 1.0 || !prefsSet) {
			SettingsHandler.setGMGenOption(InitiativePlugin.LOG_NAME + ".doSpells", true);
			SettingsHandler.setGMGenOption(InitiativePlugin.LOG_NAME + ".doDeath", true);
			SettingsHandler.setGMGenOption(InitiativePlugin.LOG_NAME + ".doHP", true);
			SettingsHandler.setGMGenOption(InitiativePlugin.LOG_NAME + ".doMaxHP", 100);
			SettingsHandler.setGMGenOption(InitiativePlugin.LOG_NAME + ".doMaxNum", 20);
			SettingsHandler.setGMGenOption(InitiativePlugin.LOG_NAME + ".doNum", 20);
			SettingsHandler.setGMGenOption(InitiativePlugin.LOG_NAME + ".ColumnName.0", "#");
			SettingsHandler.setGMGenOption(InitiativePlugin.LOG_NAME + ".ColumnWidth.0", 25);
			SettingsHandler.setGMGenOption(InitiativePlugin.LOG_NAME + ".ColumnName.1", "Name");
			SettingsHandler.setGMGenOption(InitiativePlugin.LOG_NAME + ".ColumnWidth.1", 100);
			SettingsHandler.setGMGenOption(InitiativePlugin.LOG_NAME + ".ColumnName.2", "Player");
			SettingsHandler.setGMGenOption(InitiativePlugin.LOG_NAME + ".ColumnWidth.2", 100);
			SettingsHandler.setGMGenOption(InitiativePlugin.LOG_NAME + ".ColumnName.3", "Status");
			SettingsHandler.setGMGenOption(InitiativePlugin.LOG_NAME + ".ColumnWidth.3", 75);
			SettingsHandler.setGMGenOption(InitiativePlugin.LOG_NAME + ".ColumnName.4", "+");
			SettingsHandler.setGMGenOption(InitiativePlugin.LOG_NAME + ".ColumnWidth.4", 25);
			SettingsHandler.setGMGenOption(InitiativePlugin.LOG_NAME + ".ColumnName.5", "Init");
			SettingsHandler.setGMGenOption(InitiativePlugin.LOG_NAME + ".ColumnWidth.5", 25);
			SettingsHandler.setGMGenOption(InitiativePlugin.LOG_NAME + ".ColumnName.6", "Dur");
			SettingsHandler.setGMGenOption(InitiativePlugin.LOG_NAME + ".ColumnWidth.6", 25);
			SettingsHandler.setGMGenOption(InitiativePlugin.LOG_NAME + ".ColumnName.7", "HP");
			SettingsHandler.setGMGenOption(InitiativePlugin.LOG_NAME + ".ColumnWidth.7", 25);
			SettingsHandler.setGMGenOption(InitiativePlugin.LOG_NAME + ".ColumnName.8", "HP Max");
			SettingsHandler.setGMGenOption(InitiativePlugin.LOG_NAME + ".ColumnWidth.8", 50);
			SettingsHandler.setGMGenOption(InitiativePlugin.LOG_NAME + ".ColumnName.9", "Type");
			SettingsHandler.setGMGenOption(InitiativePlugin.LOG_NAME + ".ColumnWidth.9", 50);
			SettingsHandler.setGMGenOption(InitiativePlugin.LOG_NAME + ".NumberOfColumns", 10);
			SettingsHandler.setGMGenOption(InitiativePlugin.LOG_NAME + ".DividerLocation", 450);
			SettingsHandler.setGMGenOption(InitiativePlugin.LOG_NAME + ".SubVersion", 1.0);
			SettingsHandler.setGMGenOption(InitiativePlugin.LOG_NAME + ".Version", 1.0);
		}
	}


	/**  Finishes the initialization, by implementing the last portions of the user's preferences */
	public void initLast() {
		int iDividerLocation = SettingsHandler.getGMGenOption(InitiativePlugin.LOG_NAME + ".DividerLocation", 400);
		jSplitPane1.setDividerLocation(iDividerLocation);

		//Spell Tracking On
		if (SettingsHandler.getGMGenOption(InitiativePlugin.LOG_NAME + ".doSpells", true)) {
			jToolBar2.add(bCast);
			jToolBar2.add(bEvent);
			jToolBar2.add(showEvents);
		}

		//Combat Tracking On
		if (SettingsHandler.getGMGenOption(InitiativePlugin.LOG_NAME + ".doCombat", true)) {
			jToolBar2.add(bSave);
		}

		//HP Tracking On
		if (SettingsHandler.getGMGenOption(InitiativePlugin.LOG_NAME + ".doHP", true)) {
			jToolBar2.add(bDamage);
			jToolBar2.add(bHeal);
			jToolBar2.add(bStabilize);
		}

		//Death Tracking On
		if (SettingsHandler.getGMGenOption(InitiativePlugin.LOG_NAME + ".doDeath", true)) {
			jToolBar2.add(bKill);
			jToolBar2.add(bRaise);
			jToolBar2.add(showDead);
		}

		boolean bShowDead = SettingsHandler.getGMGenOption(InitiativePlugin.LOG_NAME + ".ShowDead", false);
		showDead.setSelected(bShowDead);
		boolean bShowEvents = SettingsHandler.getGMGenOption(InitiativePlugin.LOG_NAME + ".ShowEvents", true);
		showEvents.setSelected(bShowEvents);
	}

	//** End Initialization Functions **
	public void refreshTabs() {
		Component eventTab = tpaneInfo.getComponentAt(0);
		for (int i = 0; i < initList.size(); i++) {
			InitHolder iH = (InitHolder) initList.get(i);
			if ((!iH.getStatus().equals("Dead") || showDead.isSelected()) && iH instanceof PcgCombatant) {
				PcgCombatant pcgcbt = (PcgCombatant)iH;
				if(pcgcbt.getPC().isDisplayUpdate()) {
					pcgcbt.getPC().setDisplayUpdate(false);
					removeTab(pcgcbt);
					addTab(pcgcbt);
				}
			}
		}
	}

	/**
	 * <p>
	 * Adds a tab to the <code>tpaneInfo</code> member. All methods adding
	 * character tabs to <code>tpaneInfo</code> should call this method to do
	 * so, as it provides a standard setup for the text panes and installs
	 * hyperlink listeners.
	 * </p>
	 *
	 * @param pcgcbt
	 *            Combatant to add.
	 */
	public void addTab(final PcgCombatant pcgcbt) {
		javax.swing.JTextPane lp = new javax.swing.JTextPane();
		InfoCharacterDetails ic = new InfoCharacterDetails(pcgcbt.getPC(), lp);
		tpaneInfo.addTab(pcgcbt.getName(), ic.getScrollPane());
		lp.setEditable(false);
		lp.addHyperlinkListener(new HyperlinkListener()
		{
			private PcgCombatant combatant = pcgcbt;
			public void hyperlinkUpdate(HyperlinkEvent e)
			{
				hyperLinkSelected(e, combatant);
			}
		});
	}

	public void removeTab(InitHolder iH) {
		try {
			tpaneInfo.removeTabAt(tpaneInfo.indexOfTab(iH.getName()));
		}
		catch (Exception e) {
		}
	}

	//** Table Utility Functions **
	/**  Refreshes the main table to reflect the current data in memory */
	public void refreshTable() {
		combatantTable.clearSelection();
		DefaultTableModel model = (DefaultTableModel) combatantTable.getModel();
		model.setNumRows(0);
		int startSelect = -1;
		int rowNum = 0;
		for (int i = 0; i < initList.size(); i++) {
			InitHolder c = (InitHolder) initList.get(i);
			if ((!c.getStatus().equals("Dead") || showDead.isSelected()) && (!(c instanceof Event) || showEvents.isSelected())) {
				Vector rowVector = initList.getRowVector(i, columnList);
				model.addRow(rowVector);
				int cInit = c.getInitiative().getCurrentInitiative();
				if (cInit == currentInit) {
					if (startSelect == -1) {
						startSelect = rowNum;
					}
					combatantTable.setRowSelectionInterval(startSelect, rowNum);
				}
				rowNum++;
			}
		}
		refreshEventTab();
	}

	private void refreshEventTab() {
		tpCombatInfo.setText("");
		for (int i = 0; i < initList.size(); i++) {
			InitHolder iH = (InitHolder) initList.get(i);
			StringBuffer sb = new StringBuffer();
			if(iH instanceof Event) {
				Event evt = (Event)iH;
				sb.append(evt.getName() + " (" + evt.getPlayer() + ")\n");
				sb.append("Duration: " + evt.getDuration() + "\n");
				if(evt.getEffect().length() > 0) {
					sb.append(evt.getEffect() + "\n\n");
				}
				else {
					sb.append("\n");
				}
			}
			tpCombatInfo.setText(tpCombatInfo.getText() + sb.toString());
		}
	}

	private void trackTable() {
		TableColumnModel colModel = combatantTable.getColumnModel();
		int numCols = colModel.getColumnCount();
		SettingsHandler.setGMGenOption(InitiativePlugin.LOG_NAME + ".NumberOfColumns", numCols);
		for (int i = 0; i < numCols; i++) {
			TableColumn col = colModel.getColumn(i);
			String name = col.getIdentifier().toString();
			SettingsHandler.setGMGenOption(InitiativePlugin.LOG_NAME + ".ColumnName." + i, name);
			SettingsHandler.setGMGenOption(InitiativePlugin.LOG_NAME + ".ColumnWidth." + i, col.getWidth());
		}
	}


	private void addColumn(String name, int width) {
		DefaultTableModel tabModel = (DefaultTableModel) combatantTable.getModel();
		TableColumnModel colModel = combatantTable.getColumnModel();
		tabModel.addColumn(name);
		TableColumn column = colModel.getColumn(colModel.getColumnCount() - 1);
		column.setPreferredWidth(width);
		column.setWidth(width);
		column.setIdentifier(name);
		columnList = getColumnOrder();
	}


	private void removeColumn(String name) {
		DefaultTableModel tabModel = (DefaultTableModel) combatantTable.getModel();
		TableColumnModel colModel = combatantTable.getColumnModel();
		for (int i = 0; i < colModel.getColumnCount(); i++) {
			TableColumn col = colModel.getColumn(i);
			if (col.getHeaderValue().toString().equals(name)) {
				colModel.removeColumn(col);
			}
		}
		trackTable();
		initTable();
		columnList = getColumnOrder();
	}


	private void setColumnWidths(int[] widths) {
		DefaultTableModel tabModel = (DefaultTableModel) combatantTable.getModel();
		TableColumnModel colModel = combatantTable.getColumnModel();
		for (int i = 0; i < widths.length; i++) {
			TableColumn col = colModel.getColumn(i);
			col.setPreferredWidth(widths[i]);
		}
	}


	private void checkAndFixColumns(boolean shouldExist, String colName) {
		if (shouldExist && !getColumnOrder().contains(colName)) {
			addColumn(colName, 100);
			trackTable();
		}
		else if (!shouldExist && getColumnOrder().contains(colName)) {
			removeColumn(colName);
		}
	}


	private LinkedList getColumnOrder() {
		TableColumnModel colModel = combatantTable.getColumnModel();
		LinkedList colOrder = new LinkedList();
		for (int i = 0; i < colModel.getColumnCount(); i++) {
			colOrder.add(colModel.getColumn(i).getHeaderValue());
		}
		return colOrder;
	}


	/**
	 *  Looks at each line in the table, and returns an ArrayList of lines that are Selected.
	 *
	 *@return    An ArrayList of currently selected InitHolders
	 */
	public LinkedList getSelected() {
		LinkedList retList = new LinkedList();

		int j = -1;
		for (int i = 0; i < combatantTable.getRowCount(); i++) {
			j++;
			InitHolder iH = (InitHolder) initList.get(j);
			if (iH.getStatus().equals("Dead") && !showDead.isSelected()) {
				i--;
				continue;
			}
			if(iH instanceof Event && !showEvents.isSelected()) {
				i--;
				continue;
			}
			if (combatantTable.isRowSelected(i)) {
				retList.add(iH);
			}
		}
		return retList;
	}


	/**
	 *  Returns a count of the number of lines that are selected in the table.
	 *
	 *@return    Count of the selected lines
	 */
	public int getSelectedCount() {
		return getSelected().size();
	}


	/**
	 *  Checks to see if the first current selection is an XMLCombatant
	 *
	 *@return    if the selected line is an XML Combatant
	 */
	public boolean isXMLCombatantSelected() {
		LinkedList selectedList = getSelected();
		while (!selectedList.isEmpty()) {
			InitHolder iH = (InitHolder) selectedList.removeFirst();
			return (iH instanceof XMLCombatant);
		}
		return false;
	}


	private void editTableRow() {
		int row = combatantTable.getEditingRow();
		int column = combatantTable.getEditingColumn();
		if (row > -1 && column > -1) {
			editTable(row, column);
		}
	}


	private void editTable(int row, int column) {
		InitHolder iH = (InitHolder) initList.get(row);
		Object data = combatantTable.getValueAt(row, column);
		iH.editRow(columnList, column, data);
		initList.sort();
		refreshTable();
	}


	private void addTableListener() {
		TableColumnModel colModel = combatantTable.getColumnModel();
		colModel.addColumnModelListener(
			new javax.swing.event.TableColumnModelListener() {
				public void columnAdded(javax.swing.event.TableColumnModelEvent evt) {
					colModAdded(evt);
				}


				public void columnMarginChanged(javax.swing.event.ChangeEvent evt) {
					colModMarginChanged(evt);
				}


				public void columnMoved(javax.swing.event.TableColumnModelEvent evt) {
					colModMoved(evt);
				}


				public void columnRemoved(javax.swing.event.TableColumnModelEvent evt) {
					colModRemoved(evt);
				}


				public void columnSelectionChanged(javax.swing.event.ListSelectionEvent evt) {
					colModSelectionChanged(evt);
				}
			});
	}

	//** End Table Utility Functions **

	//** Preferences Functions **
	/**  Applys preference dialog selects as new preferences, and implements those selections */
	public void applyPrefs() {
		//Combat Prefs
		if (SettingsHandler.getGMGenOption(InitiativePlugin.LOG_NAME + ".doCombat", true) && !jToolBar2.isAncestorOf(bSave)) {
			jToolBar2.add(bSave);
		}
		if (!SettingsHandler.getGMGenOption(InitiativePlugin.LOG_NAME + ".doCombat", true) && jToolBar2.isAncestorOf(bSave)) {
			jToolBar2.remove(bSave);
		}

		//Spell Prefs
		if (SettingsHandler.getGMGenOption(InitiativePlugin.LOG_NAME + ".doSpells", true) && !jToolBar2.isAncestorOf(bCast)) {
			jToolBar2.add(bCast);
			jToolBar2.add(bEvent);
		}
		if (!SettingsHandler.getGMGenOption(InitiativePlugin.LOG_NAME + ".doSpells", true) && jToolBar2.isAncestorOf(bCast)) {
			jToolBar2.remove(bCast);
			jToolBar2.remove(bEvent);
			jToolBar2.add(showEvents);
		}
		checkAndFixColumns(SettingsHandler.getGMGenOption(InitiativePlugin.LOG_NAME + ".doSpells", true), "Dur");

		//Mixed Prefs
		checkAndFixColumns(SettingsHandler.getGMGenOption(InitiativePlugin.LOG_NAME + ".doSpells", true) || SettingsHandler.getGMGenOption(InitiativePlugin.LOG_NAME + ".doDeath", true), "Status");

		//HP Prefs
		if (SettingsHandler.getGMGenOption(InitiativePlugin.LOG_NAME + ".doHP", true) && !jToolBar2.isAncestorOf(bDamage)) {
			jToolBar2.add(bDamage);
			jToolBar2.add(bHeal);
			jToolBar2.add(bStabilize);
		}
		if (!SettingsHandler.getGMGenOption(InitiativePlugin.LOG_NAME + ".doHP", true) && jToolBar2.isAncestorOf(bDamage)) {
			jToolBar2.remove(bDamage);
			jToolBar2.remove(bHeal);
			jToolBar2.remove(bStabilize);
		}
		checkAndFixColumns(SettingsHandler.getGMGenOption(InitiativePlugin.LOG_NAME + ".doHP", true), "HP");
		checkAndFixColumns(SettingsHandler.getGMGenOption(InitiativePlugin.LOG_NAME + ".doHP", true), "HP Max");
		checkAndFixColumns(SettingsHandler.getGMGenOption(InitiativePlugin.LOG_NAME + ".doNumber", true), "#");

		//Death Prefs
		if (SettingsHandler.getGMGenOption(InitiativePlugin.LOG_NAME + ".doDeath", true) && !jToolBar2.isAncestorOf(bKill)) {
			jToolBar2.add(bKill);
			jToolBar2.add(showDead);
		}
		if (!SettingsHandler.getGMGenOption(InitiativePlugin.LOG_NAME + ".doDeath", true) && jToolBar2.isAncestorOf(bKill)) {
			jToolBar2.remove(bKill);
			jToolBar2.remove(showDead);
		}

		initTable();
		refreshTable();
		this.repaint();
	}


	/**  Sets current situation for some objects as the default locations, as the program exits */
	public void setExitPrefs() {
		SettingsHandler.setGMGenOption(InitiativePlugin.LOG_NAME + ".ShowDead", showDead.isSelected());
		SettingsHandler.setGMGenOption(InitiativePlugin.LOG_NAME + ".ShowEvents", showEvents.isSelected());
		SettingsHandler.setGMGenOption(InitiativePlugin.LOG_NAME + ".DividerLocation", jSplitPane1.getDividerLocation());
	}

	//** End Preferences Functions **

	//** IO Functions **
	/**  Calls up a file save dialog, and if a file is selected/created, will then save the combatants out to disk. */
	public void saveToFile() {
		JFileChooser fLoad = new javax.swing.JFileChooser();
		File defaultFile = SettingsHandler.getPcgPath();
		if(defaultFile.exists()) {
			fLoad.setCurrentDirectory(defaultFile);
		}

		String[] fileExt = new String[] {"gmi", "init"};
		SimpleFileFilter ff = new SimpleFileFilter(fileExt, "GMGen Initiative/Encounter Export");
		fLoad.addChoosableFileFilter(ff);
		fLoad.setFileFilter(ff);
		int returnVal = fLoad.showSaveDialog(this);
		try {
			if (returnVal == JFileChooser.APPROVE_OPTION) {
				String fileName = fLoad.getSelectedFile().getName();
				String ext = "";
				if (!fileName.endsWith(".gmi")) {
					ext = ".gmi";
				}
				File xml = new File(fLoad.getSelectedFile().getParent() + File.separator +  fileName + ext);
				if (xml.exists()) {
					int choice = JOptionPane.showConfirmDialog(this, "File Exists, Overwrite?", "File Exists", JOptionPane.YES_NO_OPTION, JOptionPane.QUESTION_MESSAGE);
					if (choice == JOptionPane.YES_OPTION) {
						SettingsHandler.setPcgPath(xml.getParentFile());
						saveToDocument(xml);
					}
				}
				else {
					SettingsHandler.setPcgPath(xml.getParentFile());
					saveToDocument(xml);
				}
			}
		}
		catch (Exception e) {
			JOptionPane.showMessageDialog(this, "Error Writing File");
			Logging.errorPrint("Error Writing File");
			Logging.errorPrint(e.getMessage(), e);
		}
	}


	/**
	 *  Saves the current combatants out to an XML file
	 *
	 *@param  xml            The File to save to
	 *@exception  Exception  XML and file IO exceptions
	 */
	public void saveToDocument(File xml) throws Exception {
		Element party = new Element("Party");
		party.setAttribute("filever", "1.0");
		party.setAttribute("filetype", "initsave");
		/*if(currentInit > -1) {
			party.setAttribute("current_init", currentInit + "");
		}*/
		for (int i = 0; i < initList.size(); i++) {
			InitHolder iH = (InitHolder) initList.get(i);
			party.addContent(iH.getSaveElement());
		}
		Document saveDocument = new Document(party);
		InitOutputter xmlOut = new InitOutputter();
		xmlOut.setEncoding("US-ASCII");
		FileWriter fr = new FileWriter(xml);
		xmlOut.output(saveDocument, fr);
		fr.flush();
		fr.close();
	}

	public void loadINIT(File initFile, GMBComponent comp) {
		try {
			SAXBuilder builder = new SAXBuilder();
			Document character = builder.build(initFile);
			loadFromDocument(character, comp);
		}
		catch (Exception e) {
			JOptionPane.showMessageDialog(mainFrame, "File load error: " + initFile.getName());
			Logging.errorPrint("File Load Error" + initFile.getName());
			Logging.errorPrint(e.getMessage(), e);
		}
	}

	/**
	 *  Loads a character or party from an XML document
	 *
	 *@param  character  XML document containing a character or a party
	 */
	public void loadFromDocument(Document character, GMBComponent comp) {
		if (character.getRootElement().getName().equals("Party")) {
			Element party = character.getRootElement();
			List xmlList = party.getChildren("Character");
			ListIterator elementIterator = xmlList.listIterator();
			while (elementIterator.hasNext()) {
				Element eCharacter = (Element) elementIterator.next();
				XMLCombatant combatant = new XMLCombatant(eCharacter);
				initList.add(combatant);
			}
			List pcgList = party.getChildren("PcgCombatant");
			elementIterator = pcgList.listIterator();
			while (elementIterator.hasNext()) {
				Element eCharacter = (Element) elementIterator.next();
				final PcgCombatant combatant = new PcgCombatant(eCharacter, comp);
				initList.add(combatant);
				addTab(combatant);
			}
			List eventList = party.getChildren("Event");
			elementIterator = eventList.listIterator();
			while (elementIterator.hasNext()) {
				Element eCharacter = (Element) elementIterator.next();
				Event combatant = new Event(eCharacter);
				initList.add(combatant);
			}
			List spellList = party.getChildren("Spell");
			elementIterator = spellList.listIterator();
			while (elementIterator.hasNext()) {
				Element eCharacter = (Element) elementIterator.next();
				Spell combatant = new Spell(eCharacter);
				initList.add(combatant);
			}
			/*
			try {
				round = 0;
				int maxInit = initList.getMaxInit();
				setCurrentInit(party.getAttribute("current_init").getIntValue());
				writeToCombatTab("Combat Number " + currentCombat + ": ");
				writeToCombatTab("Round 1");
				currentCombat++;
				round = 1;
				focusNextInit();
			}
			catch (Exception e) {
			}*/
			initList.calculateNumberField();
		}
		else if (character.getRootElement().getName().equals("Character")) {
			Element eCharacter = character.getRootElement();
			XMLCombatant combatant = new XMLCombatant(eCharacter);
			initList.add(combatant);
		}
	}

	//** End IO Functions **

	//** Combat Tab Functions **
	/**
	 *  Writes out a message to the Combat window
	 *
	 *@param  message  Message to write to the Data window
	 */
	public void writeToCombatTab(String message) {
		log.logMessage(InitiativePlugin.LOG_NAME, message);
	}


	/**
	 *  Writes out a message to the Combat window, and includes the initiative that the message was written at
	 *
	 *@param  message  Message to write to the Data window
	 */
	public void writeToCombatTabWithRound(String message) {
		writeToCombatTab(" (Round: " + round + ", Init: " + currentInit + "): " + message);
	}

	//** End Combat Tab Functions **

	//** Toolbar & Button Utility Functions **
	/**  Focuses the GUI on the Next Init button */
	public void focusNextInit() {
		bNextInit.grabFocus();
	}


	/**  Focuses the GUI on the Roll button */
	public void focusRoll() {
		bRoll.grabFocus();
	}


	/**
	 *  Sets the active Initiative to be the passed in value
	 *
	 *@param  init  The new Active Initiative value
	 */
	public void setCurrentInit(int init) {
		currentInit = init;
		if (currentInit > 0) {
			lCounter.setText(round + " (" + init + ")");
		}
		else {
			lCounter.setText("");
		}
		refreshTable();
	}

	//** End Toolbar & Button Utility Functions **

	//** Functions implementing button calls for top toolbar **
	/**  Starts a new combat, and rolls a new initiative for all combatants */
	public void roll() {
		round = 0;
		initList.check();
		int maxInit = initList.getMaxInit();
		setCurrentInit(maxInit);
		writeToCombatTab("Combat Number " + currentCombat + ": ");
		writeToCombatTab("Round 1");
		currentCombat++;
		round = 1;
	}


	/**  Calls up the AddCombatant dialog for addign a new combatant */
	public void addCombatant() {
		AddCombatant dialog = new AddCombatant(mainFrame, true, this);
		dialog.setVisible(true);
		refreshTable();
	}

	public void setCombatantType() {
		Object[] possibleValues = { "PC", "Enemy", "Ally", "Non Combatant" };
		Object inputValue = JOptionPane.showInputDialog(null, "Select Combatant Type", "Input",
			JOptionPane.INFORMATION_MESSAGE, null,
			possibleValues, possibleValues[0]);

		if (inputValue != null) {
			String comString = inputValue.toString();
			if(comString.equals("Non Combatant")) {
				comString = "-";
			}
			doSetCombatantType(comString);
		}
	}

	public void doSetCombatantType(String comType) {
		LinkedList selectedList = getSelected();
		while (!selectedList.isEmpty()) {
			InitHolder iH = (InitHolder) selectedList.removeFirst();
			if(iH instanceof Combatant) {
				Combatant cbt = (Combatant) iH;
				cbt.setCombatantType(comType);
			}
		}
		refreshTable();
	}


	/**  Moves to the next active initiative */
	public void nextInit() {
		int oldInit = currentInit;
		setCurrentInit(currentInit - 1);
		int bleedingTime = SettingsHandler.getGMGenOption(InitiativePlugin.LOG_NAME + ".Damage.Dying", PreferencesDamagePanel.DAMAGE_DYING_END);

		for (int i = 0; i < initList.size(); i++) {
			InitHolder iH = (InitHolder) initList.get(i);
			if (iH instanceof Event) {
				Event e = (Event) iH;
				int eInit = e.getInitiative().getCurrentInitiative();
				if (oldInit == eInit) {
					int duration = e.decDuration();
					if (duration < 0) {
						writeToCombatTabWithRound(e.getPlayer() + "'s " + e.getName() + " ended");
						if(e.isAlert()) {
							JOptionPane.showMessageDialog(this, e.getEndText());
						}
						initList.remove(i);
					}
				}
			}
			else if (iH instanceof Combatant) {
				Combatant cbt = (Combatant)iH;
				int cInit = cbt.getInitiative().getCurrentInitiative();
				if (oldInit == cInit) {
					cbt.decDuration();
					if(bleedingTime == PreferencesDamagePanel.DAMAGE_DYING_INITIATIVE) {
						bleed((Combatant)iH);
					}
				}
			}
		}

		if (currentInit <= 0) {
			int maxInit = initList.getMaxInit();
			setCurrentInit(maxInit);
			for (int i = 0; i < initList.size(); i++) {
				InitHolder iH = (InitHolder) initList.get(i);
				if(bleedingTime == PreferencesDamagePanel.DAMAGE_DYING_END) {
					if (iH instanceof Combatant) {
						bleed((Combatant)iH);
					}
				}
				iH.endRound();
			}

			round++;
			writeToCombatTab("Round " + round);
		}
		else if (!initList.initValid(currentInit)) {
			nextInit();
		}
		refreshTable();
	}

	private void bleed(Combatant cbt) {
		if(cbt.getStatus().equals("Bleeding")) {
			int stableType = SettingsHandler.getGMGenOption(InitiativePlugin.LOG_NAME + ".Damage.Stable", PreferencesDamagePanel.DAMAGE_STABLE_PERCENT);
			if(stableType == PreferencesDamagePanel.DAMAGE_STABLE_PERCENT) {
				int roll = new Dice(1, 100).roll();
				if(roll <= 10) {
					cbt.stabilize();
					writeToCombatTabWithRound(cbt.getName() + " (" + cbt.getPlayer() + ") auto-stabilized  (" + roll + "%)");
				}
				else {
					writeToCombatTabWithRound(cbt.getName() + " (" + cbt.getPlayer() + ") failed to auto-stabilize (" + roll + "%)");
				}
			}
			else if(stableType == PreferencesDamagePanel.DAMAGE_STABLE_SAVE) {
				SavingThrowDialog dialog = new SavingThrowDialog(GMGenSystem.inst, true, cbt, 20, SavingThrowDialog.FORT_SAVE);
				dialog.show();
				dialog.dispose();

				//Show the dialog and get it's results
				int returnVal = dialog.getReturnValue();
				int roll = dialog.getRoll();
				int total = dialog.getTotal();
				int dc = dialog.getDC();

				//stabilize if the combatant passes the save
				if(dialog.getReturnValue() == SavingThrowDialog.PASS_OPTION) {
					cbt.stabilize();
				}

				//Create a message out with the results
				StringBuffer sb = new StringBuffer();
				sb.append(dialog.getSaveAbbrev(dialog.getSaveType()));
				sb.append(" save DC " + dc);
				if(roll > 0) {
					sb.append(" with a roll of " + (roll + total));
					sb.append(" (" + total + " + Roll: " + roll + ")");
				}

				//write out the results to the combat tab
				if(returnVal == SavingThrowDialog.PASS_OPTION) {
					writeToCombatTabWithRound(cbt.getName() + " (" + cbt.getPlayer() + ") Passed a " + sb.toString() + " to auto-stabilize");
				}
				else if(returnVal == SavingThrowDialog.FAIL_OPTION) {
					writeToCombatTabWithRound(cbt.getName() + " (" + cbt.getPlayer() + ") Failed a " + sb.toString() + " to auto-stabilize");
				}
			}
			String oldStatus = cbt.getStatus();
			cbt.bleed();
			String newStatus = cbt.getStatus();
			if (!oldStatus.equals(newStatus) && newStatus.equals("Dead")) {
				combatantDied(cbt);
			}
		}
	}

	/**  Refocuses the selected combatants */
	public void refocusCombatant() {
		LinkedList selectedList = getSelected();
		while (!selectedList.isEmpty()) {
			InitHolder iH = (InitHolder) selectedList.removeFirst();
			if(iH instanceof Combatant) {
				Combatant cbt = (Combatant) iH;
				cbt.init.refocus();
				writeToCombatTabWithRound(cbt.getName() + " (" + cbt.getPlayer() + ") Refocused");
			}
		}
		initList.sort();
		refreshTable();
	}


	/**  Re-rolls the selected combatant's initiatives */
	public void rerollCombatant() {
		LinkedList selectedList = getSelected();
		while (!selectedList.isEmpty()) {
			InitHolder iH = (InitHolder) selectedList.removeFirst();
			if(iH instanceof Combatant) {
				Combatant cbt = (Combatant) iH;
				cbt.init.check();
				writeToCombatTabWithRound(cbt.getName() + " (" + cbt.getPlayer() + ") Rerolled");
			}
		}
		initList.sort();
		refreshTable();
	}


	/**  Deletes the selected combatants from the Init List */
	public void deleteCombatant() {
		LinkedList selectedList = getSelected();
		while (!selectedList.isEmpty()) {
			try {
				InitHolder iH = (InitHolder) selectedList.removeFirst();
				initList.remove(iH);
				removeTab(iH);
			}
			catch (Exception e) {
			}
		}
		initList.sort();
		refreshTable();
	}

	//** End Functions implementing button calls for top toolbar **

	//** Functions implementing button calls for the bottom toolbar **

	public void rollSave() {
		LinkedList selectedList = getSelected();
		int dc = 0;
		int type = SavingThrowDialog.NULL_SAVE;
		while (!selectedList.isEmpty()) {
			InitHolder iH = (InitHolder) selectedList.removeFirst();
			if (iH instanceof Combatant) {
				Combatant cbt = (Combatant)iH;
				SavingThrowDialog dialog = new SavingThrowDialog(GMGenSystem.inst, true, cbt, dc, type);
				dialog.show();
				dialog.dispose();

				int returnVal = dialog.getReturnValue();
				int roll = dialog.getRoll();
				int total = dialog.getTotal();
				dc = dialog.getDC();
				type = dialog.getSaveType();
				StringBuffer sb = new StringBuffer();
				sb.append(dialog.getSaveAbbrev(dialog.getSaveType()));
				sb.append(" save DC " + dc);
				if(roll > 0) {
					sb.append(" with a roll of " + (roll + total));
					sb.append(" (" + total + " + Roll: " + roll + ")");
				}

				if(returnVal == SavingThrowDialog.PASS_OPTION) {
					writeToCombatTabWithRound(iH.getName() + " (" + iH.getPlayer() + ") Passed a " + sb.toString());
				}
				else if(returnVal == SavingThrowDialog.FAIL_OPTION) {
					writeToCombatTabWithRound(iH.getName() + " (" + iH.getPlayer() + ") Failed a " + sb.toString());
				}
			}
		}
		refreshTable();
	}

	/**  Calls up the CastSpell dialog, passing in the data for the first selected combatant, if there is one*/
	public void castSpell() {
		castSpell("");
	}

	/**  Calls up the CastSpell dialog, passing in the data for the first selected combatant, if there is one
	 *   sets the name of the spell as requested.
	 */
	public void castSpell(String name) {
		LinkedList selectedList = getSelected();
		while (!selectedList.isEmpty()) {
			InitHolder iH = (InitHolder) selectedList.removeFirst();
			castSpell(name, iH, null);
			return;
		}
		initList.sort();
		refreshTable();
		castSpell(name,null, null);
	}

	/**
	 * <p>Calls up the CastSpell dialog, passing the data for the indicated combatant (which
	 * may be null), and sets the name to the indicated value.  If SpellModel is present,
	 * it sets the dialog's spell model as well.</p>
	 *
	 * @param name The spell's name; may be empty string.
	 * @param iH <code>InitHolder</code> instance, may be null
	 * @param model <code>SpellModel</code> instance, may be null
	 */
	public void castSpell(String name, InitHolder iH, SpellModel model) {
		CastSpell dialog;
		if (iH == null) {
			if (mainFrame == null) {
				dialog = new CastSpell(this);
			}
			else {
				dialog = new CastSpell(mainFrame, true, this);
			}
		}
		else {
			if (mainFrame == null) {
				dialog = new CastSpell(this, iH.getPlayer(), iH.getInitiative().getCurrentInitiative());
			}
			else {
				dialog = new CastSpell(mainFrame,true,this,iH.getPlayer(),iH.getInitiative().getCurrentInitiative());
			}
		}
		if (name != null) {
			dialog.setSpellName(name);
		}
		if (model != null) {
			dialog.setSpellModel(model);
		}
		dialog.setVisible(true);
		refreshTable();
	}

	/**  Calls up the CastSpell dialog, passing in the data for the first selected combatant, if there is one*/
	public void startEvent() {
		LinkedList selectedList = getSelected();
		while (!selectedList.isEmpty()) {
			InitHolder iH = (InitHolder) selectedList.removeFirst();
			StartEvent dialog = new StartEvent(mainFrame,true,this,iH.getPlayer(),iH.getInitiative().getCurrentInitiative());
			dialog.setVisible(true);
			refreshTable();
			return;
		}
		initList.sort();
		refreshTable();
		StartEvent dialog = new StartEvent(mainFrame, true, this);
		dialog.setVisible(true);
		refreshTable();
	}

	/**  Damages the selected combatants */
	public void damageCombatant() {
		int subdualType = SettingsHandler.getGMGenOption(InitiativePlugin.LOG_NAME + ".Damage.Subdual", PreferencesDamagePanel.DAMAGE_SUBDUAL);

		DamageDialog dialog = new DamageDialog(GMGenSystem.inst, true);
		dialog.show();
		dialog.dispose();
		int returnVal = dialog.getReturn();
		if(returnVal == DamageDialog.OK_VALUE) {
			int damage = dialog.getDamage();
			if(dialog.getSubdual()) {
				if(subdualType == PreferencesDamagePanel.DAMAGE_SUBDUAL) {
					doSubdual(damage);
				}
				else if (subdualType == PreferencesDamagePanel.DAMAGE_NON_LETHAL) {
					doNonLethal(damage);
				}
			}
			else {
				doDamage(damage);
			}
		}
	}


	/**  Heals the selected combatants */
	public void healCombatant() {
		String inputValue = JOptionPane.showInputDialog(this, "Heal", 1 + "");
		if (inputValue != null) {
			try {
				Integer intValue = new Integer(inputValue);
				doHeal(intValue.intValue());
			}
			catch (NumberFormatException e) {
				healCombatant();
			}
		}
	}


	/**  Stabilizes the selected combatants */
	public void stabilizeCombatant() {
		LinkedList selectedList = getSelected();
		while (!selectedList.isEmpty()) {
			InitHolder iH = (InitHolder) selectedList.removeFirst();
			if(iH instanceof Combatant) {
				Combatant cbt = (Combatant) iH;
				writeToCombatTabWithRound(iH.getName() + " (" + cbt.getPlayer() + ") Stabilized");
				cbt.stabilize();
			}
		}
		initList.sort();
		refreshTable();
	}


	/**  Kills the selected combatants */
	public void killCombatant() {
		LinkedList selectedList = getSelected();
		while (!selectedList.isEmpty()) {
			InitHolder iH = (InitHolder) selectedList.removeFirst();
			if(iH instanceof Combatant) {
				Combatant cbt = (Combatant) iH;
				cbt.kill();
				combatantDied(cbt);
			}
		}
		initList.sort();
		refreshTable();
	}

	public void combatantDied(InitHolder deadIH) {
		writeToCombatTabWithRound(deadIH.getName() + " (" + deadIH.getPlayer() + ") Killed");
		for(int i = 0; i < initList.size(); i++) {
			InitHolder iH = (InitHolder) initList.get(i);
			String cbtType = "";
			if(iH instanceof Combatant) {
				Combatant cbt = (Combatant) iH;
				cbtType = cbt.getCombatantType();
			}
			if(cbtType.equals("Enemy") && !iH.getStatus().equals("Dead")) {
				return;
			}
		}
		writeToCombatTabWithRound("Combat finished, all enemies killed");
		checkDeadTabs();
	}

	public void checkDeadTabs() {
		for (int i = 0; i < initList.size(); i++) {
			InitHolder iH = (InitHolder) initList.get(i);
			if (iH.getStatus().equals("Dead")) {
				if(showDead.isSelected() && iH instanceof PcgCombatant && tpaneInfo.indexOfTab(iH.getName()) == -1) {
					PcgCombatant pcgcbt = (PcgCombatant)iH;
					addTab(pcgcbt);
				}
				else {
					removeTab(iH);
				}
			}
		}
	}

	/**  Raises the selected combatants from the dead */
	public void raiseCombatant() {
		LinkedList selectedList = getSelected();
		while (!selectedList.isEmpty()) {
			InitHolder iH = (InitHolder) selectedList.removeFirst();
			if(iH instanceof Combatant) {
				Combatant cbt = (Combatant) iH;
				writeToCombatTabWithRound(iH.getName() + " (" + cbt.getPlayer() + ") Raised");
				cbt.raise();
			}
		}
		initList.sort();
		refreshTable();
	}

	//** End Functions implementing button calls for the bottom toolbar **

	//** Functions called by dialogs **
	/**
	 *  Do an amount of healing to the selected combatants
	 *
	 *@param  heal  The amount of healing to do
	 */
	public void doHeal(int heal) {
		LinkedList selectedList = getSelected();
		while (!selectedList.isEmpty()) {
			InitHolder iH = (InitHolder) selectedList.removeFirst();
			if(iH instanceof Combatant) {
				Combatant cbt = (Combatant) iH;
				cbt.heal(heal);
				writeToCombatTabWithRound(cbt.getName() + " (" + cbt.getPlayer() + ") Gained " + heal + " Healing: " +
								cbt.getHP().getCurrent() + "/" + cbt.getHP().getMax());
			}
		}
		initList.sort();
		refreshTable();
	}


	/**
	 *  Do an amount of damage to the selected combatants
	 *
	 *@param  damage  The amount of damage to do
	 */
	public void doDamage(int damage) {
		LinkedList selectedList = getSelected();
		while (!selectedList.isEmpty()) {
			doDamage(damage,(InitHolder) selectedList.removeFirst());
		}
		initList.sort();
		refreshTable();
	}

	/**
	 * <p>Damages specified combatant.  This allows other methods to damage
	 * combatants who are not necessarily selected at the time.</p>
	 *
	 * @param damage
	 * 			Points of damage to do.
	 * @param iH
	 * 			InitHolder to damage.
	 */
	public void doDamage(int damage, InitHolder iH)
	{
		if(iH instanceof Combatant) {
			Combatant cbt = (Combatant) iH;
			String oldStatus = cbt.getStatus();
			cbt.damage(damage);
			String newStatus = cbt.getStatus();
			writeToCombatTabWithRound(cbt.getName() + " (" + cbt.getPlayer() + ") Took " + damage + " Damage: " +
							cbt.getHP().getCurrent() + "/" + cbt.getHP().getMax());
			doMassiveDamage(cbt, damage);
			if (!oldStatus.equals(newStatus) && newStatus.equals("Dead")) {
				combatantDied(cbt);
			}
		}
	}

	/**
	 *  Do an amount of subdual damage to the selected combatants
	 *
	 *@param  damage  The amount of damage to do
	 */
	public void doSubdual(int damage) {
		LinkedList selectedList = getSelected();
		while (!selectedList.isEmpty()) {
			InitHolder iH = (InitHolder) selectedList.removeFirst();
			doSubdual(damage, iH);
		}
		initList.sort();
		refreshTable();
	}

	/**
	 * <p>Applies subdual damage to combatant.  This allows other methods to damage
	 * combatants who are not necessarily selected at the time.</p>
	 *
	 * @param damage
	 * 			Points of damage to do.
	 * @param iH
	 * 			InitHolder to damage.
	 */
	public void doSubdual(int damage, InitHolder iH)
	{
		if(iH instanceof Combatant) {
			Combatant cbt = (Combatant) iH;
			String oldStatus = cbt.getStatus();
			cbt.subdualDamage(damage);
			String newStatus = cbt.getStatus();
			writeToCombatTabWithRound(cbt.getName() + " (" + cbt.getPlayer() + ") Took " + damage + " Subdual Damage: " +
							cbt.getHP().getCurrent() + "(" + cbt.getHP().getSubdual() + "s)/" + cbt.getHP().getMax());
		}
	}

	/**
	 *  Do an amount of non-lethal damage to the selected combatants
	 *
	 *@param  damage  The amount of damage to do
	 */
	public void doNonLethal(int damage) {
		LinkedList selectedList = getSelected();
		while (!selectedList.isEmpty()) {
			InitHolder iH = (InitHolder) selectedList.removeFirst();
			doNonLethal(damage, iH);
		}
	}

	/**
	 * <p>Applies non-lethal combatant.  This allows other methods to damage
	 * combatants who are not necessarily selected at the time.</p>
	 *
	 * @param damage
	 * 			Points of damage to do.
	 * @param iH
	 * 			InitHolder to damage.
	 */
	public void doNonLethal(int damage, InitHolder iH)
	{
		if(iH instanceof Combatant) {
			Combatant cbt = (Combatant) iH;

			boolean isEnough = false;
			if (cbt instanceof XMLCombatant) {
				XMLCombatant xmlcbt = (XMLCombatant)cbt;
				if(damage > xmlcbt.getHP().getAttribute().getValue()) {
					isEnough = true;
				}
			}
			if (cbt instanceof PcgCombatant) {
				PcgCombatant pcgcbt = (PcgCombatant)cbt;
				PlayerCharacter pc = pcgcbt.getPC();
				Globals.setCurrentPC(pc);
				StatList sl = pc.getStatList();
				if(damage > sl.getTotalStatFor("CON")) {
					isEnough = true;
				}
			}

			if(isEnough) {
				StringBuffer sb = new StringBuffer();
				SavingThrowDialog dialog = new SavingThrowDialog(GMGenSystem.inst, true, cbt, 15, SavingThrowDialog.FORT_SAVE);
				dialog.show();
				dialog.dispose();

				//Show the dialog and get it's results
				int returnVal = dialog.getReturnValue();
				int roll = dialog.getRoll();
				int total = dialog.getTotal();
				int dc = dialog.getDC();

				//Create a message out with the results
				sb.append(dialog.getSaveAbbrev(dialog.getSaveType()));
				sb.append(" save DC " + dc);
				if(roll > 0) {
					sb.append(" with a roll of " + (roll + total));
					sb.append(" (" + total + " + Roll: " + roll + ")");
				}
				if(returnVal == SavingThrowDialog.PASS_OPTION) {
					writeToCombatTabWithRound(cbt.getName() + " (" + cbt.getPlayer() + ") Passed a " + sb.toString() + " to avoid unconsiousness");
					cbt.nonLethalDamage(false);
				}
				else if(returnVal == SavingThrowDialog.FAIL_OPTION) {
					writeToCombatTabWithRound(cbt.getName() + " (" + cbt.getPlayer() + ") Failed a " + sb.toString() + " to avoid unconsiousness");
					cbt.nonLethalDamage(true);
				}
			}
		}
	}


	public void doMassiveDamage(Combatant cbt, int damage) {
		int massiveType = SettingsHandler.getGMGenOption(InitiativePlugin.LOG_NAME + ".Damage.Massive.Type", PreferencesMassiveDamagePanel.MASSIVE_DND);
		boolean isMassive = false;
		if(massiveType == PreferencesMassiveDamagePanel.MASSIVE_DND) {
			isMassive = SystemHP.isDndMassive(cbt, damage);
		}
		else if(massiveType == PreferencesMassiveDamagePanel.MASSIVE_D20_MODERN) {
			isMassive = SystemHP.isD20ModernMassive(cbt, damage);
		}
		else if(massiveType == PreferencesMassiveDamagePanel.MASSIVE_HOUSE_HALF) {
			isMassive = SystemHP.isHouseHalfMassive(cbt, damage);
		}
		if(isMassive) {
			StringBuffer sb = new StringBuffer();
			SavingThrowDialog dialog = new SavingThrowDialog(GMGenSystem.inst, true, cbt, 15, SavingThrowDialog.FORT_SAVE);
			dialog.show();
			dialog.dispose();

			//Show the dialog and get it's results
			int returnVal = dialog.getReturnValue();
			int roll = dialog.getRoll();
			int total = dialog.getTotal();
			int dc = dialog.getDC();

			//Create a message out with the results
			sb.append(dialog.getSaveAbbrev(dialog.getSaveType()));
			sb.append(" save DC " + dc);
			if(roll > 0) {
				sb.append(" with a roll of " + (roll + total));
				sb.append(" (" + total + " + Roll: " + roll + ")");
			}

			//write out the results to the combat tab
			if(returnVal == SavingThrowDialog.PASS_OPTION) {
				writeToCombatTabWithRound(cbt.getName() + " (" + cbt.getPlayer() + ") Passed a " + sb.toString() + " to avoid massive damage effects");
			}
			else if(returnVal == SavingThrowDialog.FAIL_OPTION) {
				writeToCombatTabWithRound(cbt.getName() + " (" + cbt.getPlayer() + ") Failed a " + sb.toString() + " to avoid massive damage effects");
				//Failure
				int massiveEffect = SettingsHandler.getGMGenOption(InitiativePlugin.LOG_NAME + ".Damage.Massive.Effect", PreferencesMassiveDamagePanel.MASSIVE_EFFECT_KILL);
				if(massiveEffect == PreferencesMassiveDamagePanel.MASSIVE_EFFECT_KILL) {
					cbt.kill();
					combatantDied(cbt);
				}
				else if(massiveEffect == PreferencesMassiveDamagePanel.MASSIVE_EFFECT_NEGATIVE) {
					SystemHP hp = cbt.getHP();
					int current = hp.getCurrent();
					cbt.damage(current + 1);
				}
				else if(massiveEffect == PreferencesMassiveDamagePanel.MASSIVE_EFFECT_HALF_TOTAL) {
					SystemHP hp = cbt.getHP();
					int max = hp.getMax();
					cbt.damage(max / 2);
				}
				else if(massiveEffect == PreferencesMassiveDamagePanel.MASSIVE_EFFECT_HALF_CURRENT) {
					SystemHP hp = cbt.getHP();
					int current = hp.getCurrent();
					cbt.damage(current / 2);
				}
			}
		}
	}

	/**  Shows the preferences dialog */
	public void showPreferences() {
	}

	//** End Functions called by dialogs **

	//** Copy & Paste Functions **
	/**  Copys the highlighted combatant by putting a pointer to it in copyCombatant */
	public void copy() {
		LinkedList selectedList = getSelected();
		while (!selectedList.isEmpty()) {
			InitHolder iH = (InitHolder) selectedList.removeFirst();
			if(iH instanceof Combatant) {
				copyCombatant = (Combatant)iH;
			}
		}
		initList.sort();
		refreshTable();
	}


	/**  pastes the copied combatant */
	public void pasteNew() {
		XMLCombatant newCbt;
		if (copyCombatant instanceof XMLCombatant) {
			XMLCombatant cb = (XMLCombatant) copyCombatant;
			SystemInitiative init = cb.getInitiative();
			SystemHP hitPoints = cb.getHP();
			String name = initList.getUniqueName(cb.getName());
			newCbt = new XMLCombatant(name, copyCombatant.getPlayer(), init.getAttribute().getValue(), hitPoints.getAttribute().getValue(), hitPoints.getMax(), hitPoints.getCurrent(), hitPoints.getSubdual(), init.getBonus(), cb.getCombatantType(), cb.getCR());
			initList.add(newCbt);
		}
		if (copyCombatant instanceof PcgCombatant) {
			PcgCombatant cb = (PcgCombatant) copyCombatant;
			SystemInitiative init = cb.getInitiative();
			SystemHP hitPoints = cb.getHP();
			String name = initList.getUniqueName(cb.getName());
			newCbt = new XMLCombatant(name, copyCombatant.getPlayer(), init.getAttribute().getValue(), hitPoints.getAttribute().getValue(), hitPoints.getMax(), hitPoints.getCurrent(), hitPoints.getSubdual(), init.getBonus(), cb.getCombatantType(), cb.getCR());
			initList.add(newCbt);
		}
		refreshTable();
	}

	public void addInitHolder(InitHolder iH) {
		if(iH instanceof Combatant) {
			Combatant cbt = (Combatant)iH;
			if(!initList.isUniqueName(cbt.getName())) {
				cbt.setName(initList.getUniqueName(cbt.getName()));
			}
		}
		initList.add(iH);
		if(iH instanceof PcgCombatant) {
			final PcgCombatant pcgcbt = (PcgCombatant)iH;
			addTab(pcgcbt);
	}
	}

	public void addPcgCombatant(PlayerCharacter pc, String type) {
		String name = initList.getUniqueName(pc.getName());
		if(name != pc.getName()) {
			//Means this one is already loaded, so it should be considered a new pc.
			pc.setName(name);
			pc.setFileName("");
		}
		final PcgCombatant pcgcbt = new PcgCombatant(pc, type);
		initList.add(pcgcbt);
		addTab(pcgcbt);
	}

	/**
	 * <p>Called when a hyperlink is selected in one of the text panes in <code>tpaneInfo</code>.
	 * Used to generate attack/skill, etc. dialogs.</p>
	 *
	 * @param e <code>HyperLinkEvent</code> that called this method.
	 * @param combatant <code>PcgCombatant</code> to perform action for.
	 */
	protected void hyperLinkSelected(HyperlinkEvent e, PcgCombatant combatant)
	{
		if (e.getEventType() == HyperlinkEvent.EventType.ACTIVATED)
		{
			PObjectModel model = PObjectModel.Factory(e.getDescription());
			if (model != null)
			{
				if (model instanceof AttackModel)
				{
					performAttack((AttackModel) model, combatant);
				}
				else if (model instanceof SkillModel)
				{
					checkSkill((SkillModel) model, combatant);
				}
				else if (model instanceof SpellModel)
				{
					castSpell((SpellModel) model, combatant);
				}
			}
		}
	}

	/**
	 * <p>Casts a spell based on the specified spell model.</p>
	 *
	 * @param model A <code>SpellModel</code> instance
	 * @param combatant Combatant who is casting the spell.
	 */
	private void castSpell(SpellModel model, PcgCombatant combatant)
	{
		castSpell(model.getName(), combatant, model);
	}


	/**
	 * <p>
	 * Generates a skill check dialog for a skill-check hyper link event.
	 * </p>
	 *
	 * @param model
	 * 			The skill model to roll with.
	 * @param combatant
	 * 			The combatant that's making the roll
	 */
	private void checkSkill(SkillModel model, PcgCombatant combatant)
	{
		SkillDialog dlg = new SkillDialog(model);
		dlg.setModal(true);
		dlg.show();
		dlg.dispose();
	}


	/**
	 * <p>Performs an attack action for the specified combatant.  This method
	 * constructs an AttackModel from the specified string and displays an attack
	 * dialog.</p>
	 * <p>If other combatants are present, this method passes the attack dialog
	 * a list of such combatants, and the user can choose to damage one or more of them.
	 * Deceased combatants are removed from this list, as is the current combatant.</p>
	 *
	 * @param attackString
	 * @param combatant
	 */
	public void performAttack(AttackModel attack, PcgCombatant combatant)
	{
		Vector combatants = new Vector(initList.size());
		for (int i = 0; i < initList.size(); i++)
		{
			if (initList.get(i) instanceof PcgCombatant
				&& initList.get(i) != combatant
				&& (!((InitHolder) initList.get(i)).getStatus().equals("Dead")
					|| showDead.isSelected()))
			{
				combatants.add(initList.get(i));
			}
		}
		AttackDialog dlg =
			new AttackDialog(
				attack,
				combatants);
		dlg.setModal(true);
		dlg.show();
		final ArrayList dmgList = dlg.getDamageList();
		final ArrayList targetList = dlg.getDamagedCombatants();
		if (dmgList != null && targetList != null && dmgList.size() > 0 && targetList.size() > 0)
		{
			writeToCombatTabWithRound(combatant.getName() + " successfully attacks using " + attack);
			for (int i = 0; i < dmgList.size() && i < targetList.size(); i++)
			{
				if (dlg.isSubdual())
				{
					int subdualType = SettingsHandler.getGMGenOption(InitiativePlugin.LOG_NAME + ".Damage.Subdual", PreferencesDamagePanel.DAMAGE_SUBDUAL);
					if(subdualType == PreferencesDamagePanel.DAMAGE_SUBDUAL)
					{
						doSubdual(((Integer)dmgList.get(i)).intValue(),(PcgCombatant)targetList.get(i));
					}
					else if (subdualType == PreferencesDamagePanel.DAMAGE_NON_LETHAL)
					{
						doNonLethal(((Integer)dmgList.get(i)).intValue(),(PcgCombatant)targetList.get(i));
					}
				}
				else
				{
					doDamage(((Integer)dmgList.get(i)).intValue(),(PcgCombatant)targetList.get(i));
				}
			}
			initList.sort();
			refreshTable();
		}
		else if (dmgList != null && dmgList.size() > 0)
		{
			writeToCombatTabWithRound(combatant.getName() + " successfully attacks using " + attack);
		}
		else
		{
			writeToCombatTabWithRound(combatant.getName() + " fails with attack using " + attack);
		}
		dlg.dispose();
	}

	public void removePcgCombatant(PlayerCharacter pc) {
		for(int i= 0; i < initList.size(); i++) {
			InitHolder iH = (InitHolder)initList.get(i);
			if (iH instanceof PcgCombatant) {
				PcgCombatant c = (PcgCombatant) iH;
				if(c.getPC() == pc) {
					initList.remove(iH);
					removeTab(iH);
				}
			}
		}
	}

	/**
	 *  Pastes num copies of the copied combatant
	 *
	 *@param  num  number to paste
	 */
	public void pasteNew(int num) {
		for (int i = 0; i < num; i++) {
			pasteNew();
		}
	}


	/**
	 *  Determines if there is a combatant that has been copied that is ready for pasting
	 *
	 *@return    if there is a combatant ready for pasting
	 */
	public boolean isPastable() {
		if (copyCombatant == null) {
			return false;
		}
		return true;
	}

	public void setLog(LogUtilities log) {
		this.log = log;
		if(tpaneInfo.getTitleAt(0).equals("Combat")) {
			tpaneInfo.remove(0);
		}
	}

	//** End Copy & Paste Functions **

	// Variables declaration - do not modify//GEN-BEGIN:variables
	private javax.swing.JCheckBoxMenuItem tablePopupCBStatus;
	private javax.swing.JCheckBoxMenuItem tablePopupCBName;
	private javax.swing.JToolBar jToolBar2;
	private javax.swing.JScrollPane jScrollPane1;
	private javax.swing.JCheckBoxMenuItem tablePopupCBPlayer;
	private javax.swing.JCheckBoxMenuItem tablePopupCBNumber;
	private javax.swing.JButton bCombatantReRoll;
	private javax.swing.JButton bAddCombatant;
	private javax.swing.JPanel jPanel10;
	private javax.swing.JSplitPane jSplitPane1;
	private javax.swing.JCheckBoxMenuItem tablePopupCBInitiative;
	private javax.swing.JPanel jPanel2;
	private javax.swing.JButton bDelete;
	private javax.swing.JButton bSetType;
	private javax.swing.JTable combatantTable;
	private javax.swing.JCheckBoxMenuItem tablePopupCBType;
	private javax.swing.JButton bRoll;
	private javax.swing.JCheckBoxMenuItem tablePopupCBHPMax;
	private javax.swing.JTextArea tpCombatInfo;
	private javax.swing.JToolBar jToolBar1;
	private javax.swing.JCheckBoxMenuItem tablePopupCBPlus;
	private javax.swing.JButton bNextInit;
	private javax.swing.JTabbedPane tpaneInfo;
	private javax.swing.JPopupMenu tablePopup;
	private javax.swing.JLabel lCounter;
	private javax.swing.JButton bRefocus;
	private javax.swing.JCheckBoxMenuItem tablePopupCBHP;
	private javax.swing.JCheckBoxMenuItem tablePopupCBDuration;
	// End of variables declaration//GEN-END:variables

	//** Dynamic Components **
	private JButton bSave = new JButton();
	private JButton bCast = new JButton();
	private JButton bEvent = new JButton();
	private JButton bKill = new JButton();
	private JButton bDamage = new JButton();
	private JButton bHeal = new JButton();
	private JButton bStabilize = new JButton();
	private JButton bRaise = new JButton();
	private JCheckBox showDead = new JCheckBox();
	private JCheckBox showEvents = new JCheckBox();
	private Frame mainFrame;
	//** End Dynamic Components **

	//** Other Variables **
	/**  List that contains the list of Combatants.  Kept sorted. */
	public InitHolderList initList = new InitHolderList();
	private LinkedList columnList = new LinkedList();
	private int currentInit = -1;
	private int currentCombat = 1;
	private int round = 0;
	private Combatant copyCombatant;
	private LogUtilities log;
	//** End Other Variables **
}

